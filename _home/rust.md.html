---
title: Rust
layout: dep
date: 2016-06-23
---



# enum

## `to_owned()` creates an `owned String`

e.g.
~~~rs
"hello".to_owned()
~~~




# Getting started

http://doc.rust-lang.org/book/getting-started.html

1. install `multirust`

~~~sh
//@linux
   curl -sf https://raw.githubusercontent.com/brson/multirust/master/quick-install.sh | sh

//@osx  
brew update && brew install multirust
multirust default stable
~~~

2. start with
- `cargo new ProjectName --bin`
- `cargo new LibraryName`
  - `Cargo.lock` : keeps track of dependencies in your application



## guess_game

~~~rs
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
~~~


* `cmp()` can be called on anything that can be compared
* `cmp()` takes a “reference” to the thing you want to compare it to
* `cmp()` returns the “Ordering type” instance

Ordering is an enum, short for ‘enumeration’, which looks like this:

~~~rs
let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");   
~~~

- `trim()` on Strings eliminate any white space at the beginning and end of our string
- in `read_line()` if we type 5 and hit return, guess looks like `5\n`
- `trim()` gets rid of this, leaving our string with only the `5`



~~~rs
let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");    let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
~~~

two err handlings



# Viriable Bindings

https://doc.rust-lang.org/book/variable-bindings.html


## immutables

~~~rs
let x = 5; 
let (x,y) = (1,2);
// x = 10;  // -> Err
let x = 10; // -> OK
~~~

- adding `let` bindings, we can overwrite

## mutable

~~~rs
let mut x = 5; // x is mutable
x = 10;  // OK
~~~

## scope

2 easy example of scopes

~~~rs
fn scope() {
    let x: i32 = 17;
    {
        let y: i32 = 3;
        println!("x is {} and y is {}", x, y);
    }
    // println!("x is {} and y is {}", x, y); // -> Err
}
~~~

~~~rs
fn scope2() {
    let x: i32 = 8;
    {
        println!("{}",x);
        let x = 12 ;
        println!("{}",x);
    }
    println!("{}",x);
    let x = 42;
    println!("{}",x);
}
~~~

# Functions

## arguments' type are musts

~~~rs
fn print_sum(x,y) { 
    println!(“sum is: {}”, x + y); 
} 
// this does not work

~~~

- Unlike let bindings
- you must declare the type of function arguments !!!

 ## returning

~~~rs
fn add_one (x:i32) -> i32 {
    x+1
}
 // -> i 32     shows returning a i32 typed value
 // the statement without ; is return value
~~~


## expressions vs. statements

* Ruby can be like this: `x = y = 5`

- in Rust , using let to introduce a binding is not an expression !! - “ let “ can only begin a statement , not an expression !!

~~~rs
fn expr() {
    let mut y =5;
    let x = ( y = 6 ) ;    // x has the value `()` not `6`
    println!("{:?},{}" , x, y);
}
~~~

## Early Returns

~~~rs
  fn foo(x: i32) -> i32 {
    return x ;
     // never run below
    x = x + 1;
}
~~~

## Higher Order Functions


### this works

~~~rs
fn higherOrder() {
    let x  =
    (0..).map(|n| n*n)
         .take_while(|&n| n < 1000)
         .filter(|n| is_odd(*n))
         .fold(0, |sum,i| sum + i);
    println!("{:?}" ,x);
}
~~~

### not work

~~~rs
fn higherOrder() {
    let x  =
    (0..).map(|n| n*n)
         .take_while(|&n| n < 1000)
         .filter(|n| is_odd(*n));
    println!("{:?}" ,x);
}
// this does not work
~~~


## Function Pointers

~~~rs
  let f = add_one; 
// or if add_one is without type 
// let f: fn (i32) -> i32 = add_one; let six = f(5);   
~~~



# Primitive Types




https://doc.rust-lang.org/book/primitive-types.html


## Types

char : 4bytes


pointer sized signed integer usize

IEEE754




~~~rs
rustc —version cargo new projectName —bin
~~~

types
- isize : depends on the size of a pointer of the underlying machine

~~~
let a = [1,2,3]; // immutable let mut a = [1,2,3] //mutable
~~~

~~~
cargo new primitive_types --bin
~~~

~~~
let a = [0; 20]; // [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
~~~

## Raw Pointer

as で取りださないと新しいアドレスは割り当てられない

~~~rs
let x = 5;
let raw = &x as *const i32;

let mut y = 10;
let raw_mut = &mut y as *mut i32;Run
However, dereferencing one is not. This won’t work:

let x = 5;
let raw = &x as *const i32;

println!("raw points at {}", *raw);
It gives this error:

error: dereference of raw pointer requires unsafe function or block [E0133]
     println!("raw points at {}", *raw);
                                  ^~~~
When you dereference a raw pointer, you’re taking responsibility that it’s not pointing somewhere that would be incorrect. As such, you need unsafe:

let x = 5;
let raw = &x as *const i32;

let points_at = unsafe { *raw };

println!("raw points at {}", points_at);
~~~





| c | rust |
| :---: | :---: |
| `T*` | `*mut T` |
| `const T*` | *const T |


Rust
~~~rs
// explicit cast
let i: u32 = 1;
let p_imm: const u32 = &i as const u32;

// implicit coercion
let mut m: u32 = 2;
let p_mut: *mut u32 = &mut m;

unsafe {
    let ref_imm: &u32 = &*p_imm;
    let ref_mut: &mut u32 = &mut *p_mut;
}
~~~



~~~
&*&rawだとrawがでた
~~~






c
~~~c
int x = 5;          // x = (ad_1 :Addr , val_1 :Int)
int* p              // p = (ad_2 :Addr , _     :Addr)
p = &x              // p = (ad_2 :Addr , ad_1  :Addr)

int** ppx = &&x;    // let &x = (ad_3 :Addr, ad_1:Addr) in
                    // ppx = (ad_4 :Addr, ad_3:Addr)

int& a ;        // error  '&' is not injective
~~~



## 参照渡し

http://www.asahi-net.or.jp/~yf8k-kbys/newcpp_ho3.html

＆が付くと参照渡しに
操作するものは変数の左に、　宣言は型の右に　という感じかな？
一番上は値渡しで＆がつくと参照渡しですね

- v : 自由変数
- x : 束縛変数
- 値渡し : 関数を作るときにスタックがまず作られます、そこに束縛変数（関数内のみの変数）が作られて、
その束縛変数に値が入る。なのでスタックの消滅とともに、束縛変数は消滅する


~~~rs
int i = 10;
char c = 'c';
void* a = &i;
a = &c;
~~~

Cだとキャストなしで行けたかな？

~~~c
sizeof int // 4
sizeof char // 1
sizeof void* // 4
sizeof int* // 4
sizeof char* // 4
// (32bit環境）
~~~


## bad example owing to `{:?}`

Rust
~~~rs
let x = 5;
println!("{:?}",x);             // 5
println!("{:?}",&x);            // 5
println!("{:?}",***&&&&&&&x);   // 5
~~~


C

&&&&xのアドレスが表示される
~~~
    p -> p -> p -> p -> x
    ^
    |
ここを表示
~~~


- "{:?}" で出力しているから変な事になっていたようで、"{:p}"だと素直になりました

- `&` だけでもポインタはとれていたようです


## back from pointers

~~~
`&&&x`を直接出力した場合、同じ物を出力した場合でも値が変わったので、
`&`で取るたびに新しいアドレスが割り当てられるようです
`cout >> `を採用していないのは、そういうことだったのでしょうね
~~~

## slice

~~~rs
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // A slice containing all of the elements in a
let middle = &a[1..4]; // A slice of a: only the elements 1, 2, and 3
~~~


## string

see the string chapter and reference chapter

## tuple

~~~rs
let x: (i32, &str) = (1, "hello");
// here , “hello” is referenced that is why typed &str
~~~

You can access the fields in a tuple through a destructuring let. Here’s an example:

~~~rs
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
// パターンマッチングも使えるよ！ 


// 要素一つのタプルも作れるよ！
 (0,); // single-element tuple
(0); // zero in parentheses
~~~

tuple indexing

~~~rs
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
~~~

## functions

Functions also have a type! They look like this:

~~~rs
fn foo(x: i32) -> i32 { x }

let x: fn(i32) -> i32 = foo;
~~~


# Comments

https://doc.rust-lang.org/book/comments.html

~~~
お疲れ様でした。すみませんちょっと呼び出しされてました
お疲れ様でした。
ドラゴンブックより抜粋
左辺値と右辺値
識別子は代入文の左辺に現れる場合と、右辺に現れる場合とで、異なる意味を持つ
代入文
i := 5;
i := i + 1;
において、右辺は整数値の子弟であるのに対し、左辺に現れるi は値の格納先の指定である
同様にpとq を文字へのポインタとすると
p↑ := q↑;
において、右辺のq↑は文字の子弟であるのに対し、p↑はその文字の格納先の指定であるlそこで、代入文の左辺と右辺とで、それぞれが意味する値を、左辺値、右辺値とよんで区別する。右辺値はふつう値と考えられているものであり、左辺値は格納場所を表す値である。
~~~

~~~rs
//  :  line comments
/// : Doc comments
~~~

Documentation can be generated in 2 ways ;

* from source code
* from standalone markdown

How to generate Doc

~~~sh
$ rustdoc
$ cargo doc
~~~

Doc convention in source code  

~~~rs
/// # Panics
 ///  Here write about panics 
/// # Errors
 ///  Here write about errors
 /// # Safety
 ///  Here write about safety 
/// # Examples
 ///
///  Here show example codes
 ///  # this line will not be printed
 /// fn some_function( i32: arg ) -> bool {     // implementation }
~~~


# if

~~~rs
  if () {  } else if () {  } else {  } 
~~~

~~~rs
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
~~~

# Loop

https://doc.rust-lang.org/book/loops.html

~~~rs
$ cargo new loop —bin  // create new project with name loop   # LOOPS  # loop
vim src/main.rs


 fn main() {
    call_loop();
}


fn call_loop(){
    loop {
        println!("Loop Forever!");
    }
}


 $ cargo run

~~~

## while

~~~rs
 fn call_while(){
    let mut x = 5;
    let mut done = false;
    while !done {
        x += x - 3;

        println!("{}", x);

        if x%5==0 {
            done = true;
        }
    }
}
~~~


## for


~~~rs
fn call_for() {
    for i in 0..10 {
        println!("{}", i);   // this prints 0 .. 9  , not 10
    }
}
~~~

~~~rs
for var in expression {
    code
}
~~~

The expression is an item that can be converted into an iterator using IntoIterator
Rust does not have the “C-style” for loop on purpose. Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.

## Enumerate

~~~rs
 fn call_enumerate() {
    for (i,j) in (32..40).enumerate() {
        println!("{}th input is {}", i , j);
    }
}

fn call_enumerate2() {
    let lines = "hello\nworld\nfoo\nbar!".lines();
    for (i , line) in lines.enumerate() {
        println!("{}: {}", i, line);
    }
    let chars = "hello world!".chars();
    for (i, char) in chars.enumerate() {
        println!("{}; {}", i, char);
    }
}
~~~

~~~ rs
fn call_label() {
    'outer: for i in 0..10 {
        'inner: for j in 0..10 {
            if i%2==0 {continue 'outer;}
            if j%2==0 {continue 'inner;}
            println!("{:?}",(i,j))
        }
    }
} 
~~~

# Vectors


https://doc.rust-lang.org/book/vectors.html




 vector : dynamic or growable array

- it is in standard library.
- the type is written as  “ Vec<T> ”
- where T is any type
- Vectors always allocate its data on “ heap “
- we can make vectors with “ vec![] “ macro .

~~~sh
 $ cargo new vector  --bin $ cd vector $ vim src/main.rs
~~~

~~~rs
fn gen_vectors(){
    let v1 = vec![1,2,3,4,5];
    let v2 = vec![0;10];
    println!("v1:{:?}\nv2:{:?}",v1,v2);
}


 v1:[1, 2, 3, 4, 5]
v2:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]


 errors  let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}  
~~~

today's code  ( 4.7 vector )  
~~~rs
  fn main() {
    iterate();
    error(2);
    gen_vectors();
    println!("Hello, world!");
}



fn gen_vectors(){
    let v1 = vec![1,2,3,4,5];
    let v2 = vec![0;10];
    println!("v1:{:?}\nv2:{:?}",v1,v2);
    println!("v1's third element is {}",v1[2]);
}

fn error(n: usize) {
    let v = vec![1,2,3];
    match v.get(n) {
        Some(x) => println!("the {}th element is {}", n,x),
        None => println!("Sorry the length of vector is too short")
    }
    //println!("v's 7th element is {}" , v[7]);
}


fn iterate() {
    let mut v = vec![6,2,3,4,5];
    for i in &v {
        println!("a reference to {}", i);
    }
    for i in &mut v{
        println!("a mutable reference to {}", i);
    }
    for i in v {
        println!("take ownership of the vector
                and its element and no more available orz{}" ,i);
    }
    /*
    for i in &v {
        println!("no more available because v is garbage collected {}" ,i);
    }
    */
}
~~~



# Ownership

https://doc.rust-lang.org/book/ownership.html

ownership に入ります。rust 独自機能の部分です


 goal of ownership : memory safety

3 chapters here 

- ownership
 - borrowing
 - lifetime 

Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid.
ownership を理解しないことには、コンパイル時に borrow checker と戦う羽目に陥るそうです。


- All primitive types implement the Copy trait
- vectors have pointer on stack and the data on heap

~~~rs
 $ cargo new ownership --bin
fn foo() {
    let v = vec![1, 2, 3];
}
~~~

When v comes into scope, a new vector is created on the stack, and it allocates space on the heap for its elements. When v goes out of scope at the end of foo(), Rust will clean up everything related to the vector, even the heap-allocated memory.


 vector v allows only 1 ownership !! like : 

~~~rs
 fn main() {
    println!("Hello, world!");
    change_ownership();
}

fn change_ownership(){
    let v = vec![1,2,3,4];
    take(v);
    println!("v[0] is {}" , v[0]);  // this cause error !! because v is taken its ownership by fn "take(v)"
}

fn take(v: Vec<i32>) {
}
~~~


more explanation

~~~rs
  let x = 10;
// Rust allocates memory for an integer [i32] on the stack
   let v = vec![1,2,3] 
// Rust allocates memory for 
// an object pointing data on the stack 
// and for
 // an actual data on the heap  let mut v2 = v; 
// this copies the object on stack 
// 2 pointer into 1 data is so violate that v is deleted here.

 // if we did like below , it would be danger..
v2.truncate(2);
 println!("now v[2] is {}" , v[2]);

//  copy Types

  fn copy_types() {
    let x = 1;
    let mut x2 = x;   // this do copy . not make the same pointing
    println!("x is {}",x);
}  //i32 has no pointers  //For more, if you copy your object see 
~~~


http://doc.rust-lang.org/book/traits.html

# Reference and Borrowing

https://doc.rust-lang.org/book/references-and-borrowing.html  Borrowing に入ります。 

Rust は、" zero cost abstraction " によって、安全で速い処理を実現している
これは、Rust において、"abstractions" を必要最小限にとどめるようにしようとするもの
その最たるものとして、ownership があげられる


 borrowing !

~~~rs
$ cargo new borrowing --bin $ cd borrowing $ vim src/main.rs


 We call the &T type a ‘reference’, and rather than owning the resource, it borrows ownership.  There’s a second kind of reference: &mut T. A ‘mutable reference’ allows you to mutate the resource you’re borrowing.

---
fn main() {
    func_1();
    println!("Hello, world!");
    func_2();
}



fn foo (v1: Vec<i32> , v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32){
    (v1,v2,42)
}

fn func_1() {
    let v1 = vec![1,2,3];
    let v2 = vec![1,2,3];

    let (v1,v2,answer) = foo(v1,v2);

    //println!("{},{},{}",v1,v2,answer);
}


fn foo2(v : &mut Vec<i32>) {
    v.push(5);
}


fn func_2() {
    let mut v = vec![1,2,3];
    foo2(&mut v);
    println!("{:?}",&v);
}
~~~

 borrowing は要約すれば、ownership を拝借する &T と&mut T の二つの型のことを指しているようです。
これらは参照ですが、mutable な参照とそうでない参照という二種類に分けることができ、 関数を関数プログラミングに組み込む際に必要な機能を見事に実装したものと感じました。



# Lifetimes

https://doc.rust-lang.org/book/lifetimes.html

~~~rs
// implicit
fn foo(x: &i32) {
}

// explicit
fn bar<'a>(x: &'a i32) {
}
~~~


this means that x in bar & x in foo has the same lifetime that ends in the end of the function


prerequisity

## struct & impl

struct defines parameter
impl defines methods


~~~rs
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!("{}", c.area());
}
~~~


elide :
The 't' in 'often' may be elided.








## まとめ

borrow するとき、lifetime がコンパイラによって、自動的に設定される

引数として、二つ以上 borrow するときは明示的に
return type の lifetime を選んでやる必要がありますが、
以下のように違う引数のものを選ぶとエラーとなる。

~~~rs
fn two_args<'a,'b>(x: &'a i32 , y: &'b i32)-> &'b i32
{
    &x
}

fn main() {

    let a = 999;
    let b = 888;
    println!("{}",two_args(&a,&b));

}
~~~

this causes error
confliction of lifetime
suggesting to use
`fn two_args<'a,'b>(x: &'a i32 , y: &'b i32)-> &'a i32`


# Mutability



mut is part of a pattern

e.g.

~~~rs
let (mut x, y) = (5,6); // y is not mutable

fn foo(mut x: i32) { ...
~~~


one object with two reference

~~~rs
use std::sync::Arc;

fn func_2(){
    let x = Arc::new(5);
    let y = x.clone();
    println!("{},{}",x,y);
}
// 5,5
~~~



# Clone , Copy , Drop


~~~rs
#[derive(Debug, Clone, Copy)]
struct Nil;

#[derive(Clone, Debug)]
struct Pair(Box<i32>, Box<i32>);

fn main() {

    let nil = Nil;
    let copied_nil = nil;

    let pair = Pair(Box::new(1), Box::new(2));
    println!("original: {:?}", pair);

    let moved_pair = pair;
    println!("copy: {:?}", moved_pair);

    // Error! `pair` has lost its resources
    //println!("original: {:?}", pair);
    // TODO ^ Try uncommenting this line

    let cloned_pair = moved_pair.clone();

    // Drop the original pair using std::mem::drop
    drop(moved_pair);

    // Error! `moved_pair` has been dropped
    //println!("copy: {:?}", moved_pair);
    // TODO ^ Try uncommenting this line

    // The result from .clone() can still be used!
    println!("clone: {:?}", cloned_pair);
}
~~~

the contents of `drop(a)` is done with dropping `a`

~~~rs
struct Droppable {
    name: &'static str,
}

impl Drop for Droppable {
    fn drop(&mut self) {
        println!("> Dropping {}", self.name);
    }
}
~~~
