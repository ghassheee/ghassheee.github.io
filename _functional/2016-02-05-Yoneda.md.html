---
title: Yoneda
layout: journal
---

# category theory

In this post, I assume the bunch of terms in the language "category theory", or the "presheaf theory".




# Yoneda Lemma


(Op)Yoneda Lemma

$$Hom_\mathscr{\check C}(Hom_\mathscr{C}(A,-),F) = F(A)$$




Yoneda Lemma

$$Hom_\mathscr{ \hat  C}(Hom_\mathscr{C}(-,A),F) = F(A)$$


# Yoneda Lemma in Haskell

OpYoneda Lemma is composed by a bijection

$$\phi : Hom_\mathscr{\check C}(Hom_C(A,-),F) \to F(A)$$

such that $\phi(\theta) \in F(A)$ where $\theta$ is a natural transformation and hence its type $Hom_\mathscr{\check C}(Hom_\mathscr{C}(A,-),F)$ can be rewritten by;

$$\forall K. Hom_\mathscr{\check C}(Hom_C(A,K),F(K))$$

This is

~~~ haskell
                                   ∀ K . (A → K) → F K
~~~

So in Haskell, Yoneda Lemma is written to be that a morphism $\phi$;

~~~ haskell
                        phi :: (∀ K . (A → K) → F K)) → F A
~~~

is a bijection. That is, there is an inverse morphism $\psi$;

~~~ haskell
                        psi :: F A → (∀ K . (A → K) → F K))
~~~

such that;

~~~ haskell
    psi . phi == id
    phi . psi == id
~~~


## Implementation of Yoneda Lemma


In terms of presheaf cateogry theory, Yoneda Lemma shows that `internilization` and `externalization` compose just an equivalence relation.

~~~ haskell

{-# LANGUAGE UnicodeSyntax #-}
module Yoneda where

-- #################################
-- ##         Yoneda Lemma        ##
-- #################################

internalize :: Functor f => (∀ k. (a→k)→f k) → f a
internalize t = t id
externalize :: Functor f => f a → (∀ k. (a→k)→f k)
externalize a k = fmap k a

-- such that;

--    internalize . externalize ~~ id
--    externalize . internalize ~~ id
~~~

where functional extentionality gives `~~` equality `==`.


## Proof of Yoneda Lemma

The proof is given by


~~~ haskell
int = internalize
ext = externalize

{--
int (ext a)
   = (ext a) id          [defn of int]
   = fmap id a           [defn of ext]
   = id a                [property of fmap]
   = a                   [defn of id]

ext (int t) k
   = ext (t id) k        [use defn of int]
   = fmap k (t id)       [use defn of ext]
   = k (fmap t id)       [k natural]
   = k (t . id)          [defn of fmap for ((>>) a)]
   = k t                 [property of id]
--}
~~~

I'll confirm that check f is natural, ie. that `(ext f) . (fmap g) = (fmap g) . (ext f)` ,
although, as I mentioned above, this is automatically true for polymorphic functions without funny stuff.

~~~ haskell
{--
ext f (fmap g x)
   = fmap (fmap g x) f   [defn of ext]
   = fmap (g . x) f      [defn of fmap for ((->) a)]
   = (fmap g . fmap x) f [property of fmap]
   = fmap g (fmap x f)   [defn of (.)]
   = fmap g (ext f x)    [defn of ext]
   = (fmap g . ext f) x  [defn of (.)]
--}
~~~



# Examples of Yoneda Lemma

Yoneda Lemma assumes an existence of Functor $F$. <br>
Here I provide three examples of there functors;

- $Id$
- $List$
- $Hom(C,-)$

Functor $Id$ or `I` is defined as follows;

~~~ haskell
data I a = I a
instance Functor I where
    fmap f (I a) = I (f a)
~~~

Functor $List$ or `[ ]` is defined in GHC.

Functor $Hom(C,-)$ or `((->) c)` is defined as follows;

~~~
instance Functor ((->) c) where
    fmap f = (.) f
~~~


## Continuation Passing Style

`CPS a` is a type of natural transformations in OpYoneda Lemma where $F = Id$

~~~
type CPS a =  ∀ k . (a → k) → k.
~~~

CPS(a) is the externalization of `Id(a)` such that;

~~~ haskell
toCPS :: a → (∀ k . (a → k) → k)
toCPS a f = f a
~~~

while the internalization is given by

~~~ haskell
fromCPS :: (∀ k . (a → k) → k) → a
fromCPS t = t id
~~~




`toCPS` function is the Yoneda embedding, and `fromCPS` is the inverse function.

- `toCPS` : $ \mathscr{C} \rightarrow y\mathscr{C} $
- `fromCPS` : $ y\mathscr{C} \rightarrow \mathscr{C} $


## Reverse Engineering Machines (CPSs)



￼![](/image/machine2.jpg width="600")

Reference : see [A Neighborhood of Infinity](http://blog.sigfpe.com/2006/11/yoneda-lemma.html?m=1)




When $F$ = $List$, the Yoneda Lemma gives us the listed version of CPS transformation.

`toCPSs` is a function which, given a list of terms, returns list of CPS terms.


~~~ haskell
toCPSs :: [a] → (∀ b . (a → b) → [b])
toCPSs ass f = map f ass

fromCPSs :: (∀ b . (a → b) → [b]) → [a]
fromCPSs t = t id
~~~


A set of CPS terms is like this;

~~~ haskell
CPS_as :: ∀ b . (a → b) → [b]
CPS_as f = map f ass
    where ass = undefined
~~~




### suggesting alternatives

"But what about this..." you ask, suggesting an alternative definition for the machine:

~~~ haskell
CPS_as' :: ∀ b . (a → b) → [b]
CPS_as' f = reverse $ map f ass
    where ass = (undefined)
~~~

That has the correct type signature but it doesn't seem to have the same form as machine2. However, with a tiny bit of work we can show it's functionally equivalent to one that does. In fact we can just plug `CPS_as'` into `fromCPSs` and it will give us a list of `A`'s that can be used in `CPS_as`. Instead of reverse we could use any function `[a] -> [a]` and we'd still get a sensible result out of `toCPSs`. The reason is that if `f` is of type `forall a.[a] -> [a]` then `f $ map g a` equals `map g $ f a`. (This is a Theorem for Free!.) So we can rewrite `CPS_as'` as

~~~ haskell
CPS_as'' :: ∀ b . (a → b) → [b]
CPS_as'' f = map f ass
    where ass = reverse $ (undefined)
~~~


which looks just like our `CPS_as`. So however we munge up our list to make our machine unlike machine2 we can always 'commute' the munging to the right so it acts on the internal list of A's, converting into a machine like `CPS_as`.


<br>

## Yoneda Embedding itself $\mathscr {\check y}$

Yoneda embedding $\mathscr {\check y}$ is represented by the situation that

$F$ = $Hom(C,-)$ .


Yoneda Embedding $\mathscr {\check y}$ is a contravatiant functor and hence,
it is the primitive model of CPS transformation or the Categorical Version of CPS transformation.
( See the following section. )

~~~ haskell
int         :: (∀ k . (a→k) → (c→k)) → (c→a)
int t       = t id

opyoneda    :: (c→a) → (∀ k . (a→k) → (c→k))
opyoneda        g               k   = k . g
~~~

`opyoneda` is OpYoneda Embedding of arrow $g : C \to A$, i.e. ;

$$Hom_\mathscr{\check C}(Hom_\mathscr{C}(A,-),Hom_\mathscr{C}(C,-)) = Hom_\mathscr{C}(C,A)$$

or

$$Hom_\mathscr{\check C}(\mathscr{\check y}(A),\mathscr{\check y}(C)) = Hom_\mathscr{C}(C,A)$$

~~~ haskell
opyoneda_g :: ∀ k . (a→k) → (c→k)
opyoneda_g f = f . g
    where g x = undefined
~~~



## CPS in Category Theory Style

The CPS Transformation on Type `K` is a Copresheaf Functor over the category `Hask`.

~~~ haskell
CPS(K)      :: Hask → Hom(Hask,Set)
CPS(K)      :=  Hom(Hom(-,K),K)
CPS(K) f     =  - . f
~~~

CPS transformation is just a Yoneda.<br>
Its preudo-Haskell-like syntax is written as follows;

~~~ haskell
CPS :: Hask → (B→A) → (A→K) → (B→K)
CPS    [K]      f       k   = k . f
~~~


Taking quantification on `K`, and substituting `B = 1`, we will get;
~~~ haskell
CPS A :: ∀K . (A→K)→K
~~~

Now we define the Syntax of categorical version of `STL (Simply Typed Lambda Calculus)` as follows;
~~~ haskell
t       ::= x
          | λx.M
          | (M . N)
~~~

Assuming a new Notation `(-)* := CPS`, we get;

~~~ haskell
(x)* k          := k . x
(λx.M)* k       := k . (λx.M)
                 = M* . (λm.k(λx.m))
(M . N)* k      := k . (M . N)
                 = M* . (λm.k . (m . N))
                 = M* . (λm.N* . (λn.k(m . n)))
~~~


Here, nonCPS term `t` is got by `t == t* id id` . <br>
The first argument `id` is the continuation of `t` which is the most outer continuation (or the last continuation).<br>
The second argumennt `id` is the element of Unit Type `1` with which one can get elements in Category Theory.<br>





# CoYoneda Lemma

Let $F:C\to Set$ be a covariant $C$-module ("copresheaf").<br>
The CoYoneda Lemma is left extension along the identity:

$$F \simeq \int^k F(k)\times C(k,-)$$

That is
~~~ haskell
                    F A ≃ (∃ K . F K × (A → K))
~~~

is a bijection.

The Yoneda Lemma is right extension along the identity:

$$\int_k [C(-,k),F(k)] \simeq F$$

That is
~~~ haskell
                    (∀ K . (A → K) → F K)) ≃ F A
~~~

is a bijection.



## Closure in Coyoneda

Think of the type of the following term;

~~~ haskell
let x = 3 in λy -> x + y
~~~

which is clearly, say, the form of `a -> b` .<br>


Using Closure technique, this is converted into;

~~~ haskell
let x = 3 in ([x:3], λΓ -> λy -> let x = Γ.x in x + y )
~~~

whose type is `∃ Γ . Γ × (Γ → a → b)`

So let's prove;

~~~ haskell
                    a → b ≃ ∃ Γ . Γ × (Γ → a → b)
~~~

making use of CoYoneda Lemma.






## Proof

Coyoneda Lemma is

~~~ haskell
                    F A ≃ (∃ Γ . (A → Γ) × F Γ)
~~~

Now, substituting `F := - → a → b` and `A := 1` to the Lemma, we get;

~~~ haskell
            1 → a → b ≃ ∃ Γ . (1 → Γ) × (Γ → a → b)
~~~

which is equivalent to

~~~ haskell
                a → b ≃ ∃ Γ . Γ × (Γ → a → b)
~~~

Q.E.D.






# Appendix

## funny stuff

Picture from [A Neighborhood of Infinity](http://blog.sigfpe.com/2006/11/yoneda-lemma.html?m=1)

Consider the following compiled using GHC with `-fallow-overlapping-instances -fglasgow-exts`:

~~~ haskell
class Test a where
    f :: a -> a

instance Test a where
    f = id

instance Test Int where
    f x = x+1
~~~

`f` is the identity for everything except for objects of type Int.
This is an example of what they call "funny stuff".


## caron $\check C$

The accent on this letter 'č' is called a caron or háček.
The book from which I learned about the Yoneda lemma used the caron to indicate the function I call check.
I called it that because the TeX command to produce this symbol is `\check`.
This is a multilayered pun, presumably by Knuth.

It could just be that 'check' is an anglicised abbreviation for háček.
But it's also a characterisically Czech accent so it's probably also an easier (for English speakers) spelling for 'Czech'. And I think it's also a pun on Čech.
The caron is used on an H to represent Čech cohomology and so it's also called the 'Čech' accent. (I hope you can read those characters on a PC, I wrote this on a Mac.)



<br>


## References

* [A Neighborhood of Infinity](http://blog.sigfpe.com/2006/11/yoneda-lemma.html?m=1)
* [ghasshee: CPS](/functional/2021-04-01-CPS.md/)
* [Closure in Coyoneda](http://prl.ccs.neu.edu/blog/2017/08/28/closure-conversion-as-coyoneda/)
* [Kashiwara Schapira: Categories and Sheaves]
