---
title: Yoneda
layout: journal
---




# Yoneda Lemma


Coyoneda Lemma

$$Hom_\mathscr{\check C}(Hom_\mathscr{C}(A,-),F) = F(A)$$




Yoneda Lemma

$$Hom_\mathscr{ \hat  C}(Hom_\mathscr{C}(-,A),F) = F(A)$$


# Coyoneda Lemma in Haskell

Coyoneda Lemma is composed by a bijection $\phi : Hom_\mathscr{\check C}(Hom_C(A,-),F) \to F(A)$
such that $\phi(\theta) \in F(A)$ where $\theta$ is a natural transformation and hence its type $Hom_\mathscr{\check C}(Hom_\mathscr{C}(A,-),F)$ can be rewritten by;

$$\forall K. Hom_\mathscr{\check C}(Hom_C(A,K),F(K))$$

This is

~~~ haskell
                                   ∀ K . (A → K) → F K
~~~

So in Haskell, Coyoneda Lemma is written to be that a morphism $\phi$;

~~~ haskell
                        phi :: (∀ K . (A → K) → F K)) → F A
~~~

is a bijection. That is, there is an inverse morphism $\psi$;

~~~ haskell
                        psi :: F A → (∀ K . (A → K) → F K))
~~~

such that;

~~~ haskell
    psi . phi == id
    phi . psi == id
~~~


## Implementation of Coyoneda Lemma


In terms of presheaf cateogry theory, Yoneda Lemma shows that `internilization` and `externalization` compose just an equivalence relation.

~~~ haskell

{-# LANGUAGE UnicodeSyntax #-}
module Yoneda where


-- #################################
-- ##     COYONEDA LEMMA          ##
-- #################################

internalize :: Functor f => (∀ k. (a->k)->f k) -> f a
internalize t = t id
externalize :: Functor f => f a -> (∀ k. (a->k)->f k)
externalize a k = fmap k a

~~~

such that;

~~~ haskell
    internalize . externalize ~~ id
    externalize . internalize ~~ id
~~~

where functional extentionality gives `~~` equality `==`.


## Proof of Coyoneda Lemma

The proof is given by


~~~ haskell
int = internalize
ext = externalize

int (ext f)
   = (ext f) id          [defn of int]
   = fmap id f           [defn of ext]
   = id f                [property of fmap]
   = f                   [defn of id]

ext (int f) a
   = ext (f id) a        [use defn of int]
   = fmap a (f id)       [use defn of ext]
   = f (fmap a id)       [f natural]
   = f (a . id)          [defn of fmap for ((>>) a)]
   = f a                 [property of id]
~~~

I'll confirm that check f is natural, ie. that `(ext f) . (fmap g) = (fmap g) . (ext f)` ,
although, as I mentioned above, this is automatically true for polymorphic functions without funny stuff.

~~~ haskell
ext f (fmap g x)
   = fmap (fmap g x) f   [defn of ext]
   = fmap (g . x) f      [defn of fmap for ((->) a)]
   = (fmap g . fmap x) f [property of fmap]
   = fmap g (fmap x f)   [defn of (.)]
   = fmap g (ext f x)    [defn of ext]
   = (fmap g . ext f) x  [defn of (.)]
~~~



# Examples of Coyoneda Lemma

Coyoneda Lemma assumes an existence of Functor $F$. <br>
Here I provide three examples of there functors;

- $Id$
- $List$
- $Hom(C,-)$

Functor $Id$ or `I` is defined as follows;

~~~ haskell
data I a = I a
instance Functor I where
    fmap f (I a) = I (f a)
~~~

Functor $List$ or `[ ]` is defined in GHC.

Functor $Hom(C,-)$ or `((->) c)` is defined as follows;

~~~
instance Functor ((->) c) where
    fmap f = (.) f
~~~


## Continuation Passing Style

`CPS a` is a type of natural transformations in Coyoneda Lemma where $F = Id$

~~~
type CPS a =  forall k . (a -> k) -> k.
~~~

CPS(a) is the externalization of `Id(a)` such that;

~~~
toCPS :: a -> (forall k . (a -> k) -> k)
toCPS a f = f a
~~~

while the internalization is given by

~~~
fromCPS :: (forall k . (a -> k) -> k) -> a
fromCPS t = t id
~~~




`toCPS` function is the yoneda embedding, and `fromCPS` is the inverse function.

- `toCPS` : $ \mathscr{C} \rightarrow y\mathscr{C} $
- `fromCPS` : $ y\mathscr{C} \rightarrow \mathscr{C} $


## Reverse Engineering Machines (CPSs)



￼![](/image/machine2.jpg width="600")

Reference : see [A Neighborhood of Infinity](http://blog.sigfpe.com/2006/11/yoneda-lemma.html?m=1)




When $F$ = $List$, the coyoneda lemma gives us the listed version of CPS transformation.

`toCPSs` is a function which, given a list of terms, returns list of CPS terms.


~~~hs
toCPSs :: [a] -> (forall b . (a -> b) -> [b])
toCPSs as f = map f as

fromCPSs :: (forall b . (a -> b) -> [b]) -> [a]
fromCPSs t = t id
~~~


A set of CPS terms is like this;

~~~hs
CPS_as :: forall b . (a -> b) -> [b]
CPS_as f = map f as where as = …to be determined…
~~~




### suggesting alternatives

"But what about this..." you ask, suggesting an alternative definition for the machine:

~~~hs
CPS_as' :: forall b . (a -> b) -> [b]
CPS_as' f = reverse $ map f a where a = …to be determined…
~~~

That has the correct type signature but it doesn't seem to have the same form as machine2. However, with a tiny bit of work we can show it's functionally equivalent to one that does. In fact we can just plug `CPS_as'` into `fromCPSs` and it will give us a list of `A`'s that can be used in `CPS_as`. Instead of reverse we could use any function `[a] -> [a]` and we'd still get a sensible result out of `toCPSs`. The reason is that if `f` is of type `forall a.[a] -> [a]` then `f $ map g a` equals `map g $ f a`. (This is a Theorem for Free!.) So we can rewrite `CPS_as'` as

~~~
CPS_as'' :: forall b . (a -> b) -> [b]
CPS_as'' f = map f a where a = reverse $ …to be determined…
~~~


which looks just like our `CPS_as`. So however we munge up our list to make our machine unlike machine2 we can always 'commute' the munging to the right so it acts on the internal list of A's, converting into a machine like `CPS_as`.


<br>

## Coyoneda Embedding itself $\mathscr {\check y}$

coyoneda embedding $\mathscr {\check y}$ is represented by the situation that

$F$ = $Hom(C,-)$ .


Coyoneda Embedding $\mathscr {\check y}$ is a contravatiant functor and hence,
it is the primitive model of CPS transformation or the Categorical Version of CPS transformation.
( See the following section. )

~~~
int :: (forall k . (a -> k) -> (c -> k)) -> (c -> a)
int t = t id

coyoneda :: (c->a) -> (forall k . (a->k) -> (c->k))
coyoneda       g                    k    =   k . g
~~~

`coyoneda` is Coyoneda Embedding of arrow $g : C \to A$, i.e. ;

$$Hom_\mathscr{\check C}(Hom_\mathscr{C}(A,-),Hom_\mathscr{C}(C,-)) = Hom_\mathscr{C}(C,A)$$

or

$$Hom_\mathscr{\check C}(\mathscr{\check y}(A),\mathscr{\check y}(C)) = Hom_\mathscr{C}(C,A)$$

~~~
coyoneda_g :: forall k . (a -> k) -> (c -> k)
coyoneda_g f = f . g where g x = …to be determined…
~~~



## CPS in Category Theory

`K` 上の CPS 変換　とは、圏 `Hask` 上の Copresheaf Functor です。

~~~haskell
CPS(K)      :: Hask -> Hom(Hask,Set)
CPS(K)      =  Hom(Hom(-,K),K)
CPS(K) f    =  - . f
~~~

これは単に、CoYoneda Embedding と呼ばれるものです。<br>
CPS 変換とはただの Coyoneda です。

Haskell 風に書くと
~~~ haskell
CPS :: Hask -> (B->A) -> (A->K) -> (B->K)
CPS    (K)       f    =   \k    ->  k f
~~~

となります。<br>
`K` に関して量化し、`B = 1` とすると、
~~~ haskell
CPS A :: ∀K . (A→K)→K
~~~

を得ます。

これをそのまま STL (単純型付λ計算) `t ::= x | λx.M | (M . N) `  上で実装しますと、<br>
`(-)* := CPS`  として、

~~~haskell
(x)* k    := k . x
(λx.M)* k := k . (λx.M)
           = M* . (λm.k(λx.m))
(M . N)* k  := k . (M . N)
           = M* . (λm.k . (m . N))
           = M* . (λm.N* . (λn.k(m . n)))
~~~

となります。<br>
`t == t* id id`　として得られます。<br>
（ここで、一つ目の `id` は `t` の継続、二つ目の `id` は型 `1` (Unit型)の要素です。）



<br>



# category theory




# Appendix

## funny stuff



Consider the following compiled using GHC with `-fallow-overlapping-instances -fglasgow-exts`:

~~~
class Test a where
    f :: a -> a

instance Test a where
    f = id

instance Test Int where
    f x = x+1
~~~

f is the identity for everything except for objects of type Int.
This is an example of what I call "funny stuff".


## caron

The accent on this letter 'č' is called a caron or háček.
The book from which I learned about the Yoneda lemma used the caron to indicate the function I call check.
I called it that because the TeX command to produce this symbol is `\check`.
This is a multilayered pun, presumably by Knuth.

It could just be that 'check' is an anglicised abbreviation for háček.
But it's also a characterisically Czech accent so it's probably also an easier (for English speakers) spelling for 'Czech'. And I think it's also a pun on Čech.
The caron is used on an H to represent Čech cohomology and so it's also called the 'Čech' accent. (I hope you can read those characters on a PC, I wrote this on a Mac.)



<br>
