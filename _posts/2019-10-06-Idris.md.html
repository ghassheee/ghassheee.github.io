---
    title: Idris
    layout: dep
    date: 2019-10-06
---

Reference : [10 things Idris Improved over Hasekll](https://deque.blog/2017/06/14/10-things-idris-improved-over-haskell/)

# Idris Strings are not Lists

Haskell Strings are not efficient.
Most Newcomers encounter the efficiency.

- Haskell Programmer usually uses `Data.ByteString` or `Data.Text` instead.
- Strings are not First Class in Haskell, and it forces to use the `Overloaded Strings extension`

ris learned from the mistakes of Haskell and made Strings first class. You can call pack and unpack strings to go back an forth to a List Char representation.

~~~hs
caesar_cipher : Int -> String -> String
caesar_cipher shift input =
    let cipher = chr . (+ shift) . ord
    in pack $ map cipher (unpack input)

> caesar_cipher 1 "abc"	=> "bcd"
> caesar_cipher 0 "abc"	=> "abc"
~~~


# namespace

~~~hs
infixr 5 +.
namespace Scalar
    (+.) : Int -> Int -> Int
    x +. y = x + y
namespace Vector
    (+.) : List Int -> List Int -> List Int
    xs +. ys = zipWith (+) xs ys

> 3 +. 5	=> 8 : Int
> [1, 2, 3] +. [4, 5]	=> [5, 7] : List Int
~~~

# Records fields are namespaced

~~~hs
record Account where
    constructor MkAccount
    accound_id : String
    address : String
record Customer where
    constructor MkCustomer
    name : String
    address : String
    account : Account
~~~



~~~hs
custom_billing_account : Customer -> Bool
custom_billing_account customer =
    address customer /= address (account customer)
~~~


# Records update and access syntax

~~~
update_billing_address : Customer -> String -> Customer
update_billing_address customer address =
    record { account->address = address } customer
~~~

~~~
concat_billing_address : Customer -> String -> Customer
concat_billing_address customer complement =
    record { account->address $= (++ complement) } customer
~~~

~~~
john : Customer
john = MkCustomer "John" "NYC" (MkAccount "123" "NYC")

update_billing_address john " LND"
=> MkCustomer "John" "NYC" (MkAccount "123" "LND") : Customer
concat_billing_address john " LND"
=> MkCustomer "John" "NYC" (MkAccount "123" "NYC LND") : Customer
~~~

# Monad and Functor got fixed

~~~hs
Idris> :doc Monad

Interface Monad
Parameters:
    m
Constraints:
    Applicative m
Methods:
    (>>=) : Monad m => m a -> (a -> m b) -> m b
    join : Monad m => m (m a) -> m a
~~~

~~~
Idris> :t map
map : Functor f => (a -> b) -> f a -> f b
~~~

# Laziness is opt-in, not opt-out

There are plenty of good reasons for laziness, there is no denying it. Reading the amazing Why Functional Programming matters shows how much it helps modularising and decoupling our software, by allowing the separation of processes producing data from the one consuming it.

But there are plenty of drawbacks to laziness as well. Some are technical (space leaks) and some are psychological (non strict evaluation is not intuitive when coming from other languages).

A bit like Clojure (and other FP languages) did before, Idris embraces opt-in laziness, with a strict evaluation by default. Streams are the lazy equivalent of Lists and the language features both. You can notice the different pretty easily, when playing with infinite and finite ranges:

~~~
Idris> :t [1 .. 10]
enumFromTo 1 10 : List Integer
Idris> :t [1 ..]
enumFrom 1 : Stream Integer
~~~

# A smaller Num class

~~~
Idris> :doc Num

Interface Num
    The Num interface defines basic numerical arithmetic.
Parameters:
    ty
Methods:
    (+) : Num ty => ty -> ty -> ty
    (*) : Num ty => ty -> ty -> ty
    fromInteger : Num ty => Integer -> ty
Child interfaces:
    Integral ty
    Fractional ty
    Neg ty
~~~

#  The Cast type class

Idris removed the Read type class and replaces it with the more general Cast type class. The Read type class allowed to parse a String into a type a, effectively a transformation from a String to any other type. The Cast class is parameterized on the input type as well, allowing to transform between any two types implementing the type class.

~~~
Idris> :doc Cast
Interface Cast
    Interface for transforming an instance of a data type to another type.
Parameters:
    from, to
Methods:
    cast : Cast from to => (orig : from) -> to
~~~

~~~
the Int (cast "abc")
=> 0 : Int
the Int (cast "123")
=> 123 : Int
the Int (cast 1.1)
=> 1.0 : Int
~~~


# Clear separation of evaluation and execution

Let us write a simple function that reads the input from the command line, interprets it as a number, double this number, before printing it on the screen:

~~~
double_it : IO ()
double_it = do
    input <- getLine
    let n = the Int (cast input)
    printLn (n * 2)
~~~

If you evaluate a call to this function in the Idris REPL, you will get the following big pile of Abstract Syntax Tree, which correspond to the recipe to execute the IO expression described by double_it:

~~~
[*src/InOut> double_it	io_bind (io_bind prim_read	                 (\x =>	                    io_pure (prim__strRev (with block in Prelude.Interactive.getLine', trimNL (MkFFI C_Types String String)	                                                                                              (prim__strRev x)	                                                                                              (with block in Prelude.Strings.strM (prim__strRev x)	                                                                                                                                  (Decidable.Equality.Bool implementation of Decidable.Equality.DecEq, method decEq (not (intToBool (prim__eqString (prim__strRev x)	                                                                                                                                                                                                                                                    "")))	                                                                                                                                                                                                                    True))))))	        (\input =>	           io_bind (prim_write (prim__concat (prim__toStrInt (prim__mulInt (prim__fromStrInt input) 2)) "\n"))	                   (\__bindx => io_pure ())) : IO ()
~~~

To execute the function and not just evaluate it, you need to say so explicitly, by using :exec as prefix to the expression to execute:

~~~
[*src/InOut> :exec double_it
123 -- My input
246 -- Output
~~~


# The Do notation without monads

I kept the best part of Idris for the last. Before of its support for overloading, Idris allows the developer to define a bind operator out of the Monad class, and the do notation is based on the sole presence of this operator.

This is truly an awesome idea. It allows the developer to profit from the nice syntax of the do notation, without having to comply to the interface of the Monad bind operator.

- It avoids forcing awkward design just to fit the Monad type class requirements
- It opens up the notation for numerous types that could not be made proper instance of Functor, Applicative or Monad, because they are not parameterised
- It allows to keep the do notation for dependent types, which much rarely conform to the interface of Monad

It also allows us to abuse even more the do notation. More power means more changes to do horrors as well. Here is an example of abuse that shows that we do not even need a parameterized type for the do notation anymore:

- It describes a not very useful StringBuilder DSL
- Evaluating an expression of this DSL with eval_string yields a String
- Defining the bind operator allows us to describe our DSL expression with do

~~~
data StringBuilder
    = Pure String
    | (>>=) StringBuilder (String -> StringBuilder)
eval_string : StringBuilder -> String
eval_string (Pure s) = s
eval_string (x >>= f) = eval_string (f (eval_string x))
~~~

Here is an example of usage of this DSL, in which we create an StringBuilder expression named john, using our beloved and dreaded do notation:

~~~
build_john : StringBuilder
build_john = do
    john <- Pure "John"
    let john_doe = john ++ " Doe" ++ concat (replicate 10 "!")
    Pure john_doe
~~~

Evaluating our StringBuilder expression shows us the AST, and calling eval_string on it interprets it as a String:

~~~
[*src/DoNotation> build_john
Bind (Pure "John") (\john => Pure (prim__concat john " Doe!!!!!!!!!!")) : StringBuilder

[*src/DoNotation> eval_string build_john
"John Doe!!!!!!!!!!" : String
~~~

Idris offers some pleasant surprises for the Haskell programmers, even without considering the dependent typing support. There are many other pleasant surprises I got, such as the distinction between print and printLn, which is now aligned with putStr and putStrLn, and many others.

These changes mostly show how helpful it is to be able to start all over again from scratch and fixing these pesky mistakes we did at the beginning.
