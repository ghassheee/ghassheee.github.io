---
title : TaPL
layout: dep
---

Reference

* [Pierce] Types and Programming Languages

<br>

# Introduction

TaPL provides type safe programming language definitions.<br>
It is formally named `typed lambda calculus` .<br>
If you are not familir with lambda calculus ,
I recommend you to start with combinator theory .<br>
"Mock a mockingbird" is a book with famous logic thinking puzzle written by Raymond Smullyan.

<br>
<br>
<br>

# Mathematical Prerequired Definitions


## `powerset`

$ \mathcal{P} ( \mathcal{S} ) := \{ U ; U \subset S \} $

## `difference`

$ \mathcal{S} \ \backslash \ \mathcal{T} \ := \ S ‚à©  T ^ C  $

## `natural numbers`

$ \mathbb{N} := \{ 0,1,2,3,4,5,6,7,8, ... \} $

## `n-placed relation`

$ s_1 \in \mathcal{S_1} , ... , s_n \in \mathcal{S_n} $ are `n-place related` <br>
`if` $ (s_1, ... , s_2) \in R $ where $ R \subseteq \mathcal{S_1} \times ... \times \mathcal{S_n} $

## `predicate ( 1-place relation )` P

$ P(s) := s \in P $

## `Binary Relation` R

$ s R t := ( s , t ) \in R $
<br>    where $ s, t \in \mathcal{ U } $

## `2-place Relation` R

$ s R t := ( s , t ) \in R $
<br>    where $ s \in \mathcal{S} , t \in \mathcal{T} $

## `3-place Relation`

see `n-place Relation `. e.g. ;

* $ \Gamma \vdash s : T $  ( Typing Relation (see Chapter 9) )

## `Partial Function` R

$ s R t_1 \wedge s R t_2 \Rightarrow t_1 = t_2 $

## `Total Function` R

$ dom(R) = \mathcal{S} $
<br>    where $ \mathcal{S} R \mathcal{T} $

## `Defined` / `Undefined`

Partial Function $ s R t $ is defined on $ s \in \mathcal{S} $ if $ s \in dom(R) $

* $ f(x) \uparrow $ , $ f(x) = \uparrow $ : $ f $ is undefined on $ x $
* $ f(x) \downarrow $ , $ f(x) = \downarrow $ : $ f $ is defined on $ x $

## `Diverge` ‚â† `Failure`

* `function`„ÅÆÂÆüË£ÖÊôÇ„ÄÅÂá∫ÂäõÂÄ§ `failure` „ÅØ Âá∫ÂäõÂÄ§ `divergence` „Å®Âå∫Âà•„Åó„Å™„ÅÑ„Å®„ÅÑ„Åë„Å™„ÅÑ.
* fail „ÇíÂá∫Âäõ„Åô„ÇãÈñ¢Êï∞„ÅØ `Partial` „Åß„ÅÇ„Çä `divergeble` „Åß„ÅÇ„ÇäÂæó„Çã„Åå„ÄÅ`Total` „Åß„ÅÇ„Çå„Å∞„ÄÅÂÖ•Âäõ„Å´ÂÜçÂ∏∞„ÅØÂê´„Åæ„Çå„Å™„ÅÑ
* R„ÅÆ input „Åß„ÅÇ„Çã$ dom(R) $ „ÅØ„ÄÅ$ \mathcal{S} $ „ÅÆË¶ÅÁ¥†„Å´Èôê„Çâ„Çå„Çã


## `Predicate`„ÄÄ

* $ s \in P $ „Åß„ÅÇ„Çå„Å∞ s„ÅØËø∞Ë™û„ÇíÊåÅ„Å§„Å®„ÅÑ„ÅÜ
* where $ s \in \mathcal{S} , P \subseteq \mathcal{S} $

e.g.

* $ s \in P := P(\mathcal{S}) = $ { $ True , False $ }
* $ P := s \rightarrow $ { $ True , False $ }


Ëø∞Ë™û„ÇíÊåÅ„Åü„Åõ„Çã„ÅÆ„ÅØ [Russell's Paradox](../math/2015-12-15-russell.md/) „ÇíËß£Ê∂à„Åï„Åõ„Çã„Åü„ÇÅ


**********************************
*                                *
*         s R t                  *
*         ^   ^                  *
*        /     \                 *
*   domain     range , codomain  *
*   dom(R)        range(R)       *
*                                *
**********************************



# Untyped Arithmetic Expressions

# ML implementation

# Untyped lambda calsulus

## term definition

Syntax are given by;

~~~
t := x                        <variable>
   | Œªx. t                    <Œª abstraction>
   ‚à£ t t                      <application>
~~~

and its evaluation is given by;

~~~
(Œªx. t)  t'  ‚Üí   t[x‚Ü¶t']
~~~

We read the right hand side "replace all x which appears in t with t' ".

## e.g. S K I combinator

For example, K and S are Œª abstractions.

~~~
K := Œªx. Œªy. x
S := Œªx. Œªy. Œªz. ((x)(z))(y z)
~~~

K takes x and y as its arguments and returns x.
S takes x, y, and z as its arguments and returns `(x z) (y z)`

~~~
S K K x
= ((K)(x))(K x)
= (Œªx. Œªy. x) (x) (K x)
= x
~~~

Thus, identity combinator is given by `I` := `S K X`.



## church booleans

~~~hs
tru = \t.\f. t
fls = \t.\f. f
and = \x.\y. x y fls
or  = \x.\y. y tru x
not = \x. x fls tru
~~~

## pairs

~~~
pair = \f.\s.\b. b f s
fst  = \p. p tru
snd  = \p. p fls
~~~


## if

~~~
if b s t = b s t
~~~

## church numerals

### ‚Ñï

~~~hs
0 = \s.\z. z        -- = \x.\y. y = fls
1 = \s.\z. s z
2 = \s.\z. s (s z)
3 = \s.\z. s (s (s z))
...
~~~



Rewrite in `MockingBird Style`
~~~hs
        0xy = y
        1xy = xy
        2xy = x(xy)
        3xy = x(x(xy))
        ...
~~~

### `succ`

~~~hs
        S0xy = xy
        S1xy = x(xy)
        S2xy = x(x(xy))
        ...
~~~

solve S !
~~~hs
        x(x(xy)) = x(2xy) = S2xy
        x(xy) = x(1xy) = S1xy
        so, Snxy = x(nxy)
        or
        x(x(xy)) = 2x(xy) = S2xy
        x(xy) = 1x(xy) = S1xy
        so , Snxy = nx(xy)
~~~

hence,
~~~hs
suc = \n.\s.\z. s(nsz)
    = \n.\s.\z. ns(sz)
~~~

### `plus`

~~~hs
plus = \m.\n.\x.\y. mx(nxy)
plus m n x y = mx(nxy)

plus m n x y
= x(x(x(x(xy))))
= mx(nxy)
~~~

### `times`

~~~hs
times m n x y
= x(x(x(x(x...(xy)))))    // x appears m * n
= x(x(x(           )))    // now m = 3
= mx   (x(x...(xy)))
= mx(mx(mx..(mxy)))       // mx appears by n times
= n(mx)y
or similarly
= m(nx)y

so
times = \m.\n.\x.\y. m(nx)y
times = \m.\n.\x.\y. n(mx)y
~~~

now with `plus`
~~~
times = \m.\n. m(plus n)0
times m n = m(plus n)0
~~~

### `pow`

in the same way
~~~
pow = \m.\n. m(times n)1
pow m n = m(times n)1
~~~

another solution
~~~
pow = \m.\n. n m
pow m n = n m
~~~

### `iszro`

~~~
iszro = \m. m (\x.fls) tru


let
F x = fls
in
iszro m = m F tru
~~~

e.g.
~~~
iszro 5
= 5 F tru
= F(F(F(F(F tru))))
= fls               // because F always returns fls

iszro 0
= 0 F tru
= tru
~~~

### `prd`

let
~~~
zz = pair 0 0
ss p = pair (snd p) (+ 1 (snd p))
~~~

then pred is
~~~
prd m = fst (m ss zz)
~~~

e.g.
~~~
prd m
= fst (m ss zz)
= fst (ss(ss(...(ss zz)...)))
= fst (pair {m-1} m)
= m-1


where,
ss zz
= pair (snd (pair 0 0)) (+ 1 (snd (pair 0 0)))
= pair 0 1

ss (ss zz)
= pair (snd (pair 0 1)) (+ 1 (snd (pair 0 1)))
= pair 1 2

...
~~~

~~~
prd 0
= fst (0 ss zz)
= fst (zz)
= fst (pair 0 0)
= 0
~~~



### `sub`


~~~
sub m n = n prd m
~~~

### `equal`  / `or` `and`

~~~
equal m n = and (iszro (sub m n))(iszro (sub n m))
~~~

where

~~~
or = \b.\c. b tru c
and = \b.\c. b c fls
~~~


## list

lists are functions like
~~~
[x,y,z] c n = cx(cy(czn))
[x,y] c n = cx(cyn)
[x] c n = cxn
nil c n = n

nil == fls
~~~


cons takes a value and a list and returns a list

~~~
cons x list c n = c x (list c n)



cons x [y,z,a,...] = [x,y,z,a,...]
cons x nil c n
= c x (nil c n)
= c x n
= [x] c n
cons x nil = [x]
~~~


so,lists are composed of cons and its arguments like;
~~~
[x,y,z,a,b]
= cons x [y,z,a,b]
= cons x (cons y [z,a,b])
= cons x (cons y (cons z [a,b]))
= cons x (cons y (cons z (cons a [b])))
= cons x (cons y (cons z (cons a (cons b nil))))
~~~

~~~
[nil] c n
= cons nil nil c n
= [nil] cons nil c n
= cons nil nil c n
= c nil (nil c n)
= c nil n
~~~

so ,it seems that

`nil` $ \neq $ `[nil]`



e.g.
~~~
cons x [y,z] c n
= c x ([y,z] c n)
= c x (c y (c z n))
~~~

~~~
isnil list = list F tru

F x y = fls
~~~

e.g.
~~~
isnil [x]
= [x] F tru
= F x tru
isnil [x,y]
= [x,y] F tru
= F x (F y tru)
~~~

~~~
head list = list tru nil
~~~



tail ..

think the same with `prd`

~~~
pair nil nil
pair nil [z]
pair [y] [y,z]
pair [y,z] [x,y,z]
...

tail list = fst (list cc nn)
cc x p = pair (snd p)(cons x (snd p))
nn = pair nil nil

tail [x,y,..,z]
= fst ([x,y,..,z] cc nn)
= fst (cc x (cc y(..(cc z nn)..)))
= fst (cc x (cc y(..(pair nil [z])..)))
= fst (pair [y,..,z] [x,y,..,z])
= [y,..,z]
~~~

another solution of list
~~~
nil = pair tru tru;
cons = Œªh. Œªt. pair fls (pair h t);
head = Œªz. fst (snd z);
tail = Œªz. snd (snd z);
isnil = fst;
~~~
mocking bird style;
~~~
nil = pair tru tru
cons x list = pair fls (pair x list)
head list = fst (snd list)
tail list = snd (snd list)
isnil list = fst
~~~

such that ;
~~~
isnil (pair tru tru) = tru
isnil (pair fls (..)) = fls
~~~

but this definition is not satisfying
~~~
[x,t,..,z] c n = cx(cy(..(czn)))
~~~

## Enriching Calculus

## Recursion


fixed point Œª function
~~~
fix = \f. (\x.f ( \y.xxy )) (\x.f ( \y.xxy ))
~~~
f_sumlist = \rec.\l. test (isnil l)
                         (\x. 0)
                         (\x. plus (head l) (rec (tail l)))

sumlist = fix f_sumlist

I think that another definition of ‚Äúsumlist‚Äù is very cool,
while the recursive and fixed-point-using one is very long ‚Ä¶ ( ex 5.2.11 )

~~~
Def.
‚Ä®sumlist = \x.x plus 0

‚Ä®‚Ä®e.g.
‚Ä®sumlist [x,y,z]‚Ä®
= [x,y,z] plus 0
‚Ä®= plus x ( plus y ( plus z 0 ))
~~~

moreover ,

~~~
‚Ä®Def.
‚Ä®prodlist = \x.x times 1

e.g.
‚Ä®prodlist [x,y,z]
‚Ä®= [x,y,z] times 1
‚Ä®= times x ( times y ( times z 1 ))
~~~

furthermore, we can define ‚Äúfoldr‚Äù function in haskell ;

~~~
‚Ä®‚Ä®Def.
‚Ä®foldr = \x. \f. \i. x f i‚Ä®‚Ä®

e.g.‚Ä®
foldr [x,y,z] f i‚Ä®
= [x,y,z] f i
‚Ä®= f x ( f y ( f z i ))
~~~

## Evaluation Strategies


We can classify evaluations into 2 different strategies,
lazy evaluation and call-by-value evaluation.
lazy evaluation can be further classified into `call-by-name` `call-by-need`.

~~~
(Œªx. t)  t'  ‚Üí   t[x‚Ü¶t']
~~~

„Å†„Å®Ë®Ä„Å£„Åü„Åå„ÄÅ„Åì„Çå„Åß„ÅØ„ÄÅ`t` „Å® `t'` „ÅÆ„Å©„Å°„Çâ„Åã„ÇâÂÖà„Å´Ë®àÁÆó„Åô„Çå„Å∞„Çà„ÅÑ„ÅÆ„Åã„Å™„Å©‰∏çÁ¢∫ÂÆö„Å™ÊÉÖÂ†±„ÅåÂ§ö„Åè„ÄÅ„Åù„Çå„Çâ„ÅØÂÆüË£Ö„Å´‰æùÂ≠ò„Åô„Çã„ÄÇ
„Åì„Çå„ÇíÈÅø„Åë„Çã„Åü„ÇÅ„Å´„ÄÅÊòéÁ§∫ÁöÑ„Å´Ë©ï‰æ°Êà¶Áï•„ÇíÁ§∫„Åó„Å¶„ÇÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÄÇ

Ë©ï‰æ°Êà¶Áï•„Å®„ÅÑ„ÅÜ„ÅÆ„ÅØ„ÄÅÊßãÊñáÊú®„ÅÆ„Å©„Åì„Åã„Çâ„Å©„ÅÆ„Çà„ÅÜ„Å™Ë¶èÂâá„Åß„ÄÅËøî„ÇäÂÄ§„Çí„ÇÇ„Å®„ÇÅ„Å¶„ÅÑ„Åè„Åã„ÄÇ
„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„ÅÇ„Çã„ÄÇ
ÈõªÂçì„ÅÆÁ∞°Âçò„Å™‰æã„Åß„ÅÑ„Åà„Å∞„ÄÅ`1+1*1` „ÅÆÊéõ„ÅëÁÆó„ÇíÂÖà„Å´„Åô„Çã„ÅÆ„Åã„ÄÅË∂≥„ÅóÁÆó„ÇíÂÖà„Å´„Åô„Çã„ÅÆ„Åã„ÄÅ„Å®„ÅÑ„Å£„ÅüÂïèÈ°å„ÇÇË©ï‰æ°Êà¶Áï•„ÅÆÂïèÈ°å„Åß„ÅÇ„Çã„ÄÇ
TaPL „Å´Ë®òËºâ„Åï„Çå„Å¶„ÅÑ„Çã4„Å§„ÅÆË©ï‰æ°Êà¶Áï•„ÅØÊ¨°„ÅÆ„Å®„Åä„Çä„Åß„ÅÇ„Çã„ÄÇ

![TaPL1.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/321074/b7d66c69-3529-8f86-9518-d38299199456.png)

ÂÆüÈöõ„Å´„ÄÅ„Åì„Çå„Çâ„ÅÆË®àÁÆó„Çí
`times (times 3 (times 2 1))` „Å´ÂØæ„Åó„Å¶„ÄÅÈÅ©Áî®„Åó„Åü„ÅÆ„Åå„ÄÅÊ¨°„Åß„ÅÇ„Çã„ÄÇ

![TaPL.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/321074/4812ce71-097a-ec3b-b4d6-2e8c5e101f71.png)



### call by value

OCaml has call by value strategy which defines the following 1-step evaluations;

~~~ml
let rec isval ctx = function
    | TmAbs(_,_,_,_)                        -> true
    | _                                     -> false

let rec eval1 ctx = function
    | TmApp(fi,TmAbs(_,x,tyT11,t12),v2) when isval ctx v2
                                            ->  termSubstTop v2 t12
    | TmApp(fi,v1,t2) when isval ctx v1     ->  TmApp(fi,v1,eval1 ctx t2)
    | TmApp(fi,t1,t2)                       ->  TmApp(fi,eval1 ctx t1,t2)
    | _                                     ->  raise NoRuleApplies
~~~


and the multi step evaluation is defined as;

~~~ml
let rec eval ctx t =
    try eval ctx (eval1 ctx t)
    with NoRuleApplies -> t
~~~



# de Bruijn

## Naming Variables

~~~
(\f. (\x.(f x) x)(\x.(f x) x)) (\x.x)
~~~

‰∏≠„ÅÆ `\x.(f x) x` „Å´„ÅØ„ÄÅÂ§ñ„Åã„Çâ `f` „ÇíÊ∏°„Åó„Å¶„ÇÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÄÇ<br>
„Å§„Åæ„Çä„ÄÅcontext „ÅØÂ§ñ„Åã„Çâ„ÄÅŒªÂºè„ÅÆ‰∏≠„Å´ÂÖ•„ÇãÊôÇ„Å´ÔºàÂ§ñ„ÅÆÈ†Ö„ÅÆË©ï‰æ°„Åã„Çâ‰∏≠„ÅÆÈ†Ö„Å∏„Å®Ë©ï‰æ°„ÅåÁßª„Çã„Å®„Åç„Å´ÔºâÂ¢ó„Åà„Çã„ÄÇ

Êñ∞„Åó„ÅÑ„Çπ„Ç≥„Éº„Éó„ÅÆ‰∏≠„Å´ÂÖ•„ÇäÂ±ÄÊâÄÂ§âÊï∞„ÅåÂ¢ó„Åà„Çã„Å®ËÄÉ„Åà„Çã„Åì„Å®„ÇÇ„Åß„Åç„Çã



## Context Œì „ÅÆÂ∞éÂÖ•

ÈÄöÂ∏∏„ÅÆ„É©„É†„ÉÄË®àÁÆó„Åß„ÅØ„ÄÅÂ§âÊï∞„Çí‰Ωø„ÅÜ„Åå„ÄÅ
Â§âÊï∞„Å´Êï∞Â≠ó„ÇíÁî®„ÅÑ„Å¶ÂêçÂâç„Çí‰ªò„Åë„ÄÅ`Œì` „Å´‰øùÂ≠ò„Åô„Çã„ÄÇ„Åì„ÅÆ `Œì` „Çí Name Context „Å®Âëº„Å∂„ÄÇ
‰æã„Åà„Å∞„ÄÅŒì = {  a $\mapsto$ 2, b $ \mapsto $ 1, c $ \mapsto $ 0 } „Åß„ÅÇ„Çå„Å∞„ÄÅÔºì„Å§„ÅÆÂ§âÊï∞„Åå‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ
„Åì„ÅÆ Name Context „Å´„Çà„Å£„Å¶
„Åü„Å®„Åà„Å∞„ÄÅ`(a b) c`  „ÅØ„ÄÅ`(2 1) 0` „Å®Ëß£Èáà„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÄÇ
`Œªc.Œªd.c d d`„ÅÆ„Çà„ÅÜ„Å´„ÄÅ„ÄåÊùüÁ∏õÂ§âÊï∞„Äç„ÇíÔºíÂÄãÊåÅ„Å§Âºè„ÅØ„ÄÅ
Œì „Å´Êñ∞„Åü„Å´Ôºí„Å§„ÅÆ mapping „Çí„ÄÅ
Œì = {a $\mapsto$ 4, b $ \mapsto $ 3, c $ \mapsto $ 2, c' $ \mapsto $ 1, d $ \mapsto $ 0} „Å®„ÄåÂè≥„Åã„ÇâÁ©ç„ÇÄ„Äç„Åì„Å®„Åß„ÄÅ
`Œª.Œª.1 0 0`„ÅÆ„Çà„ÅÜ„Å´Ë°®Ë®ò„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÄÇ

## SHIFT / SUBSTITUTION

„Åì„ÅÆ„Çà„ÅÜ„Å´„ÄÅÊñ∞„Åó„ÅÑÂ§âÊï∞„ÇíÁ©ç„ÇÄÈöõ„Å´„ÄÅËá™Áî±Â§âÊï∞ `{a,b,c}` „Å´Èñ¢„Åó„Å¶„ÅØ„ÄÅ `+2`„Å†„Åë `shift` „Åó„Å¶„ÇÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÄÇ„Åù„Åó„Å¶„ÄÅ‰∏ÄÊôÇÈôê„Çä„ÅÆÊùüÁ∏õÂ§âÊï∞„Çí‰ΩøÁî®„Åó„Åü„ÅÇ„Å®„ÅØ„ÄÅÈÄÜ„Å´`-2` `shift` „Åó„Å¶„ÇÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÄÇ

„Åì„Çå„ÅåÂÖ∑‰ΩìÁöÑ„Å´Ë°å„Çè„Çå„Çã„ÅÆ„ÅØ„ÄÅ Application `(Œªx.t) s` „ÅÆÊ¨°„ÅÆÂ∑•Á®ã„ÄÅ
Substitution `[x ‚Ü¶ s] t` „Å´„Åä„ÅÑ„Å¶„Åß„ÅÇ„Çã„ÄÇ

„Åì„Çå„ÇíÂÆüË£Ö„Åó„Åü„ÇÇ„ÅÆ„Åå„ÄÅ
shift / substitution
„Åß„ÅÇ„Çã„ÄÇ„ÄÇ

~~~ml
(* syntax.ml *)
...

(* -------------------------------------------------- *)
(* Shifting *)

let rec walk funOnVar c   = let f = funOnVar in function
    | TmVar(fi,x,n)             -> funOnVar fi c x n
    | TmAbs(fi,x,tyT,t2)        -> TmAbs(fi,x,tyT,walk f(c+1)t2)
    | TmApp(fi,t1,t2)           -> TmApp(fi, walk f c t1, walk f c t2)
    | TmIf(fi,t1,t2,t3)         -> TmIf(fi,walk f c t1, walk f c t2, walk f c t3)
    | TmSucc(fi,t)              -> TmSucc(fi, walk f c t)
    | TmPred(fi,t)              -> TmPred(fi, walk f c t)
    | TmIsZero(fi,t)            -> TmIsZero(fi, walk f c t)
    | x                         -> x

let termShiftOnVar d        = fun fi c x n ->   if x>=c then TmVar(fi,x+d,n+d) else TmVar(fi,x,n+d)
let termShiftAbove d        = walk (termShiftOnVar d)
let termShift d             = if d>=0 then print_endline ("SHIFT: "^(string_of_int d));termShiftAbove d 0

(* -------------------------------------------------- *)
(* Substitution *)
let termSubstOnVar j s t    = fun fi c x n ->   if x=j+c then termShift c s else TmVar(fi, x, n)
let termSubst j s t         = walk (termSubstOnVar j s t) 0 t
let termSubstTop s t        = print_endline "SUBSTITUTE: "; termShift (-1) (termSubst 0 (termShift 1 s) t)
~~~


# ML implementation of Lamda Calculus

# Typed Arithmetic Expressions


## Types

~~~
t ::=
    true
    false
    if t then t else t
    0
    succ t
    pred t
    iszero t
~~~

~~~
v ::=
    true
    false
    nv

nv ::=
    0
    succ nv
~~~



## The Typing Relation

$ \mathbb{B} $

~~~
T ::=
    Bool
~~~

~~~
  true : T

  false : T

   t1 : Bool   t2 : T   t3 : T
  ------------------------------
    if t1 then t2 else t3 : T

~~~

$ \mathbb{B}\ \mathbb{N} $
~~~
T ::=
    Nat
~~~

~~~
   0 : Nat

      t1 : Nat
   ----------------
    succ t1 : Nat

      t1 : Nat
   ----------------
    pred t1 : Nat

        t1 : Nat
   ------------------
    iszero t1 : Bool

~~~



## Safety = Progress + Preservation

Progress : A well-typed term is not stuck
~~~
    t is well typed => t is value | t -> t'
~~~

Preservation : (subject reduction)
~~~
    If a well-typed term takes a step of evaluation,
    then the resulting term is also well typed.

    t:T & t->t' => t':T
~~~

### opposite theorem
~~~
    t':T & t->t'  => t:T
~~~
is not True
(if false then true else 0)



### think of `big step`

big step always reach final value.
so you cannot think recursion


### think of `wrong` term

preservation theorem tells:
well-typed term cannot reach wrong term







# Simple Typed Lambda Calculus




Âûã‰ªò„Åç„É©„É†„ÉÄË®àÁÆó„Å®„ÅØ„ÄÅÈ†Öt „Å´ÂØæ„Åó„ÄÅType Context $ \Gamma $ „Å®„ÄÅÂûã $ T $ „ÇíËøΩÂä†„Åó„Åü„ÇÇ„ÅÆ„Åß„ÅÇ„Çã„ÄÇÂÆüË£Ö„Å´„Åä„ÅÑ„Å¶„ÄÅ„Åì„ÅÆ Type Context $ \Gamma $ „Å®„ÄÅ„Åï„Åç„Åª„Å©Âá∫„Å¶„Åç„Åü Name Context $ \Gamma $ „Å™„Å©„ÄÅÊßò„ÄÖ„Å™Á®ÆÈ°û„ÅÆ Context „Çí„Çø„Ç∞‰ªò„Åë„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅÂêå„ÅòÂûã„ÅÆ Context „Å®„Åó„Å¶ÂÆüË£Ö„Åó„Å¶„ÅÑ„Çã„ÄÇÔºà„Åü„Å†„ÅóÂÆüË°åÊôÇ„ÄÅÊßãÊñáËß£ÊûêÂô®„Åå‰ΩøÁî®„Åô„Çã `Name Context` „Å®„ÄÅÂûãÊ§úÊüªÊ©ü„Åå‰ΩøÁî®„Åô„Çã Type Context „ÅØÁï∞„Å™„Çã„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„Çã„ÄÇÔºâ„Åì„ÅÆ Context $ \Gamma $ „ÅØ„ÄÅ„Åì„ÅÆ„Çà„ÅÜ„Å´ÂÆüË°åÊôÇ„Å´„Åä„Åë„ÇãÊßò„ÄÖ„Å™Áí∞Â¢ÉË¶ÅÁ¥†„ÇíÂê´„Çì„Åß„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅÆÂÆüË°åÊôÇÁí∞Â¢É„Å™„Å©„Å®Âëº„Å∂„Åì„Å®„ÇÇ„ÅÇ„Çã„Åå„ÄÅÂÆüË°åÊôÇÁí∞Â¢É„Å´„ÅØ‰ªñ„Å´„ÇÇC(Constraint 22Á´†) „ÇÑ Œ£(Store 16Á´†) „Å™„Å©„Åå„ÅÇ„Çä„ÄÅÊõñÊòßÊÄß„Çí„ÇÇ„Å§„ÄÇ„Åù„ÅÆ„Åü„ÇÅ„Åµ„Å§„ÅÜ $ \Gamma $ „ÅØ„ÄÅ„Äå (Type) Context „Äç„Å®Âëº„Å∂„ÄÇ

„Ç≥„É≥„ÉÜ„ÇØ„Çπ„Éà„Å®„ÄÅÈ†Ö„ÄÅÂûã„ÅÆÈñ¢‰øÇ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢‰øÇ ( 3-placed relation ) „ÅßË°®„Åó„ÄÅ

$ \Gamma \vdash  t : T $

„Äå„Ç≥„É≥„ÉÜ„ÇØ„Çπ„Éà $ \Gamma $ „Å´„Åä„Åë„ÇãÈ†Ö t „ÅÆÂûã„ÅØ„ÄÅT „Åß„ÅÇ„Çã„Äç„Å®„Çà„ÇÄ„ÄÇ

## ÊßãÊñá Syntax

Âûã‰ªò„É©„É†„ÉÄË®àÁÆó„ÅÆÊúÄ„ÇÇÂ∞è„Åï„ÅÑÊßãÊñá„ÅØ„ÄÅ

~~~
    t  ::=                              term
            x                           variable
            Œªx:T.t                      abstraction
            t t                         application

    v  ::=                              value
            Œªx:T. t                     abstraction value

    T  ::=                              type
            T ‚Üí T                       arrow type

    Œì  ::=
            ‚àÖ                           empty context
            Œì,x:T                       term variable binding
~~~

„Åß„ÅÇ„Çã„ÄÇ

ÂÄ§ v „ÅØ„ÄÅ„Åù„Çå‰ª•‰∏äÂçòÁã¨„ÅßË©ï‰æ°„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Å™„ÅÑÈ†Ö„Åß„ÅÇ„Çã„ÄÇ„Åï„Åç„Åª„Å©Ëø∞„Åπ„Åü„ÄÅË©ï‰æ°Êà¶Áï• call by value „ÅÆÁ≠ñÂÆö„Å´„ÄÅ„Åì„ÅÆ v „ÅåÂ§ß„Åç„ÅèÈñ¢„Çè„Å£„Å¶„Åè„Çã„ÄÇ


Âûã T „ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆÈ†Ö„ÅØÈñ¢Êï∞„Å†„Å®„ÅÑ„ÅÜ„ÄÅÈñ¢Êï∞ÂûãË®ÄË™û„ÅÆÊÄùÊÉ≥„Çí„Çà„ÅèË°®„Åó„Å¶„Åä„Çä„ÄÅ„Åô„Åπ„Å¶ Arrow Type „ÅÆÂΩ¢„Åß„Åã„Åë„Çã„ÄÇÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„ÄÅ„Åì„Çå„Å´$ \mathbb{B} $ „ÅÆ„Çà„ÅÜ„Å™Âü∫Êú¨Âûã„ÇíÂä†„Åà„Çã„ÅÆ„Åß„ÄÅ‰ª•‰∏ã„ÅÆÊñπ„ÅåÊÉ≥ÂÉè„Åó„ÇÑ„Åô„ÅÑ„ÅÆ„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„ÄÇ

~~~
    T  ::=                              type
            B                           boolean type
            T ‚Üí T                       arrow type
~~~

„Å®„ÅÑ„Å£„ÅüÂÖ∑Âêà„Åß„ÅÇ„Çã„ÄÇ

Œì „ÅØ„ÄÅType Context „Åß„ÅÇ„Çã„ÄÇ

$ \Gamma $ :=
~~~
    x_n -> n : Tn
    ...
    x_1 -> 1 : T1
    x_0 -> 0 : T0
~~~

## Function(Arrow) Type


~~~
T ::= ...
    | T -> T
~~~

Arrow Types are right associative;  i.e. `T->T->T` means `T->(T->T)`  .




## Ë©ï‰æ°Ë¶èÂâá Evaluation Rules

Ë©ï‰æ°Ë¶èÂâá„ÅØ„ÄÅÂÖà„Åª„Å©„ÅÆ„Å®„Åä„Çä„Åß„ÅÇ„Çã„ÄÇ

~~~
                    t1   ‚Üí  t1'
          -------------------------------------- [E-APP1]
                 t1 t2   ‚Üí  t1' t2


                    t2   ‚Üí  t2'
          -------------------------------------- [E-APP2]
                 v1 t2   ‚Üí  v1 t2'


          (Œªx:T11.t) v2  ‚Üí  [x ‚Ü¶ v2] t           [E-APPABS]
~~~

## Âûã‰ªò„ÅëË¶èÂâá Typing Rules

„Åì„Çå„Å´„ÄÅÂûãË¶èÂâá„ÇíÂ∞éÂÖ•„Åó„Åü„ÅåÂΩ¢Êúâ„Çä„É©„É†„ÉÄË®àÁÆó„Åß„ÅÇ„Çã„ÄÇ

~~~
                    x : T ‚àà Œì
          -------------------------------------- [T-VAR]
                    Œì ‚à£- x : T


                   Œì,(x:S) ‚à£- t : T
          -------------------------------------- [T-ABS]
                  Œì ‚à£- Œªx:S.t : X ‚Üí T


            Œì |- t1 : T2 -> T ,   Œì ‚à£- t2 : T2
          -------------------------------------- [T-APP]
                    Œì ‚à£- t1 t2 : T
~~~








# ML implementaion of Simple Types


ÂÖ∑‰ΩìÁöÑÂÆüË£Ö„Å´„Åä„Åë„ÇãÊßãÊñá„ÇÑ„ÄÅ
ÂûãË¶èÂâá„ÄÅË©ï‰æ°Êà¶Áï•„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„Å™„Çã„ÄÇ

ÂûãË¶èÂâá„ÅØ„ÄÅ`typeof` Èñ¢Êï∞„ÅÆÂÆüË£Ö„Åß„ÅÇ„Çä„ÄÅ
Ë©ï‰æ°Êà¶Áï•„ÅØ„ÄÅ`eval1` Èñ¢Êï∞„ÅÆÂÆüË£Ö„Åß„ÅÇ„Çã„ÄÇ

„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ„ÄÅ[github „É¨„Éù„Ç∏„Éà„É™](https://www.github.com/kripkejoyal/ocamyl)„Å´„ÅÇ„Çã„ÄÇ


## ÊßãÊñá

~~~hs

/* Modules both for Interpreter and for Compiler */
Command     :       /* A top-level command */
    | Term                          { fun ctx   -> let t = $1 ctx in Eval(tmInfo t,t),ctx }
    | LCID Binder                   { fun ctx   -> ((Bind($1.i,$1.v,$2 ctx)), addname ctx $1.v) }
Binder      :
    | COLON Type                    { fun ctx   -> VarBind($2 ctx) }

Type        :
    | ArrowType                     { $1 }
AType       :
    | LPAREN Type RPAREN            { $2 }
    | BOOL                          { fun ctx   -> TyBool }
    | NAT                           { fun ctx   -> TyNat  }
ArrowType   :
    | AType ARROW ArrowType         { fun ctx   -> TyArr($1 ctx, $3 ctx) }
    | AType                         { $1 }

Term        :
    | AppTerm                       { $1 }
    | LAMBDA LCID COLON Type DOT Term
        { pe "PARSER: Œªx:T.t"; fun ctx -> let ctx1=addname ctx $2.v in TmAbs($1,$2.v,$4 ctx,$6 ctx1)}
    | IF Term THEN Term ELSE Term   { fun ctx   -> TmIf($1, $2 ctx, $4 ctx, $6 ctx) }
AppTerm     :
    | ATerm                         { $1 }
    | SUCC ATerm                    { fun ctx   -> TmSucc($1, $2 ctx ) }
    | PRED ATerm                    { fun ctx   -> TmPred($1, $2 ctx ) }
    | ISZERO ATerm                  { fun ctx   -> TmIsZero($1, $2 ctx) }
    | AppTerm ATerm                 { fun ctx   -> let e1=$1 ctx in TmApp(tmInfo e1,e1,$2 ctx) }
ATerm       :         /* Atomic terms are ones that never require extra parentheses */
    | LPAREN Term RPAREN            { pe "PARSER: ( t )"; $2 }
    | LCID                          { fun ctx   -> TmVar($1.i, name2index $1.i ctx $1.v, ctxlength ctx) }
    | TRUE                          { fun ctx   -> TmTrue($1) }
    | FALSE                         { fun ctx   -> TmFalse($1) }
    | INTV                          { fun ctx   -> let rec f = function
              0 -> TmZero($1.i)
            | n -> pe "succ"; TmSucc($1.i, f (n-1))
          in f $1.v }
~~~


## Ë©ï‰æ°Âô®

~~~ml
open Format
open Core
open Support.Pervasive
open Support.Error
open Syntax
open Arg
open Type

exception NoRuleApplies

let rec isnumericval ctx = function
    | TmZero(_)         -> true
    | TmSucc(_,t1)      -> isnumericval ctx t1
    | _                 -> false

let rec isval ctx = function
    | TmAbs(_,_,_,_)                -> true
    | TmTrue(_)                     -> true
    | TmFalse(_)                    -> true
    | t when isnumericval ctx t     -> true
    | _                             -> false

let rec eval1 ctx = function
    | TmApp(fi,TmAbs(_,x,tyT11,t12),v2) when isval ctx v2
                                        ->  termSubstTop v2 t12
    | TmApp(fi,v1,t2) when isval ctx v1 ->  TmApp(fi,v1,eval1 ctx t2)
    | TmApp(fi,t1,t2)                   ->  TmApp(fi,eval1 ctx t1,t2)
    | TmIf(_,TmTrue(_),t2,t3)           ->  t2
    | TmIf(_,TmFalse(_),t2,t3)          ->  t3
    | TmIf(fi,t1,t2,t3)                 ->  let t1' = eval1 ctx t1 in TmIf(fi, t1', t2, t3)
    | TmSucc(fi,t1)                     ->  let t1' = eval1 ctx t1 in TmSucc(fi, t1')
    | TmPred(_,TmZero(_))               ->  TmZero(dummyinfo)
    | TmPred(_,TmSucc(_,nv1)) when (isnumericval ctx nv1)
                                        ->  nv1
    | TmPred(fi,t1)                     ->  TmPred(fi, eval1 ctx t1)
    | TmIsZero(_,TmZero(_))             ->  TmTrue(dummyinfo)
    | TmIsZero(_,TmSucc(_,nv1)) when (isnumericval ctx nv1)
                                        ->  TmFalse(dummyinfo)
    | TmIsZero(fi,t1)                   ->  let t1' = eval1 ctx t1 in TmIsZero(fi, t1')
    | _                                 ->  raise NoRuleApplies

let rec eval ctx t =
    try eval ctx (eval1 ctx t)
    with NoRuleApplies -> t



let rec process_command ctx = function
    | Eval(fi,t)                ->
            let tyT = typeof ctx t in
            printtm_ATerm true ctx (eval ctx t);
            print_break 1 2; pr ": "; printty tyT; force_newline(); ctx
    | Bind(fi,x,bind)           ->  pr ("Now, "^x^ " is a variable: "); prbindingty ctx bind; force_newline(); addbinding ctx x bind


let print_eval ctx cmd      =
    open_hvbox 0;
    process_command ctx cmd;
    print_flush ()

~~~


## ÂûãËß£ÈáàÂô®

~~~ml
open Format
open Core
open Support.Pervasive
open Support.Error
open Syntax
open Arg

exception NoRuleApplies


(* ----------- TYPING --------------- *)

let rec typeof ctx   t      = pr "TYPEOF: ";printtm ctx t;print_newline ();  match t with
    | TmVar(fi,i,_)             -> getTypeFromContext fi ctx i
    | TmAbs(fi,x,tyT1,t2)       ->
            let ctx'    = addbinding ctx x (VarBind(tyT1)) in
            let tyT2    = typeof ctx' t2 in
            TyArr(tyT1,tyT2)
    | TmApp(fi,t1,t2)           ->
            let tyT1 = typeof ctx t1 in
            let tyT2 = typeof ctx t2 in
            (match tyT1 with
                | TyArr(tyT11,tyT12)    -> if (=) tyT2 tyT11 then tyT12 else error fi "type mismatch"
                | _                     -> error fi "arrow type expected" )
    | TmTrue(fi)                -> TyBool
    | TmFalse(fi)               -> TyBool
    | TmZero(fi)                -> TyNat
    | TmSucc(fi,t)              -> if (=) (typeof ctx t) TyNat then TyNat else error fi "succ expects ùêç"
    | TmPred(fi,t)              -> if (=) (typeof ctx t) TyNat then TyNat else error fi "succ expects ùêç"
    | TmIsZero(fi,t)            -> if (=) (typeof ctx t) TyNat then TyBool else error fi "iszero expects ùêç"
    | TmIf(fi,t1,t2,t3)         -> if (=) (typeof ctx t1) TyBool then
                let tyT2 = typeof ctx t2 in
                if (=) tyT2 (typeof ctx t3) then tyT2 else error fi "resulting type of if statement mismatch"
                else error fi "if-condition expects a boolean"


(* ---- *)

let prbindingty ctx = function
    | NameBind                  -> ()
    | VarBind(tyT)              -> pr ": "; printty tyT




~~~


## (Áï™Â§ñÁ∑®) Â∑¶ÂÜçÂ∏∞„Å®Âè≥ÂÜçÂ∏∞

### ÊßãÊñáËß£Êûê„ÅÆÁü•Ë≠ò

ÊßãÊñá„Å´„ÅØ„ÄÅÂ∑¶ÂÜçÂ∏∞ÊßãÊñá„Å®Âëº„Å∞„Çå„ÇãÊßãÊñá„Å®„ÄÅÂè≥ÂÜçÂ∏∞ÊßãÊñá„Å®Âëº„Å∞„Çå„ÇãÊßãÊñá„Åå„ÅÇ„Çã„ÄÇ
Ê≠£Ë¶èË°®Áèæ ab* „ÅÆÊßãÊñá„ÅÆÂÆöÁæ©ÊñπÊ≥ï„Å®„Åó„Å¶„ÄÅ

~~~
Left Recursion

t ::=
     | a
     | t b
~~~


„Å®„ÅÑ„ÅÜÂÆöÁæ©ÊñπÊ≥ï„Åå„ÅÇ„Çä„ÄÅ„Åì„Çå„ÇíÂ∑¶ÂÜçÂ∏∞„Å®„ÅÑ„ÅÜ„ÄÇ
Êñá `abbb` „ÇíËß£Êûê„Åô„Çã„Å®„ÄÅ

~~~
  ((((a) b) b) b)

           t
          / \
         t   b
        / \
       t   b
      / \
     t   b
    /
   a
~~~

„Åì„Çå„Å´ÂØæ„Åó„ÄÅÂè≥ÂÜçÂ∏∞ÊßãÊñá„Å®„ÅØ„ÄÅ

~~~
Right Recursion

t  ::=
     |  a s

s  ::=
     |  ‚àÖ
     |  b s
~~~

„ÅÆ„Çà„ÅÜ„Å™ÂÆöÁæ©„Åß„ÅÇ„Çä„ÄÅ

~~~

   (a (b (b (b ‚àÖ))))


      t
     / \
    a   s
       / \
      b   s
         / \
        b   s
           / \
          b   ‚àÖ
~~~


„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´„ÄÅÂè≥„Å∏„ÄÅÊßãÊñáÊú®„ÅåÂûÇ„Çå‰∏ã„Åå„Å£„Å¶„ÅÑ„Åè„ÄÇ

ÊßãÊñáËß£ÊûêÂô®„ÄÅÂ≠óÂè•Ëß£ÊûêÂô®„Å®„ÇÇ„Å´„ÄÅÈÄöÂ∏∏Êñá„ÇíÂ∑¶„Åã„ÇâÈ†ÜÁï™„Å´Ë™≠„ÅøËæº„Çì„Åß„ÅÑ„ÅèÔºàËµ∞Êüª„Åó„Å¶„ÅÑ„ÅèÔºâ„ÄÇ

Êñá„ÇíÂ∑¶„Åã„ÇâËµ∞Êüª„Åó„Å¶„ÅÑ„Åè„Å®„Åç„ÄÅ
Âè≥ÂÜçÂ∏∞ÊßãÊñá„Åß„ÅØ„ÄÅÊúÄÂæå„ÅÆ‚àÖ „ÅåË¶ã„Åà„Çã„Åæ„Åß„ÄÅs „ÇÇ t „ÇÇ„Åù„ÅÆÂÜÖÂÆπÁâ©„ÅåÁ¢∫ÂÆö„Åó„Å™„ÅÑ„ÅÆ„Å´ÂØæ„Åó„Å¶„ÄÅ
Â∑¶ÂÜçÂ∏∞ÊßãÊñá„Åß„ÅØ„ÄÅÊØéÂ∫¶ÊØéÂ∫¶„ÄÅÂêÑ t „ÅÆÂÜÖÂÆπÁâ©„ÅåÁ¢∫ÂÆö„Åô„Çã„ÄÇ



###  „Ç≥„É≥„Éë„Ç§„É©„Å®„Ç§„É≥„Çø„Éó„É™„Çø„ÅÆÈÅï„ÅÑ

„Ç§„É≥„Çø„Éó„É™„Çø„ÅØÊ≠¢„Åæ„Çâ„Å™„Åè„Å¶„ÇÇ„ÅÑ„ÅÑ„ÅÆ„Åß„ÄÅ„Å®„Çä„ÅÇ„Åà„Åö„ÄÅÂÖ•Âäõ„ÅÆÊúÄÂàù„Åã„ÇâÈ†ÜÁï™„Å´Ë©ï‰æ°„Åó„Å¶„ÅÑ„Åë„Å∞„Çà„ÅÑ„Åå„ÄÅ
ÂÖ•Âäõ„ÅÆÂàó„ÅåÈÄîÁµ∂„Åà„Çã„Åã„Å©„ÅÜ„Åã„ÅØ„Åæ„Å£„Åü„ÅèÊ∞ó„Å´„Åó„Å™„Åè„Å¶„Çà„ÅÑ„ÄÇ„ÇÄ„Åó„ÇçÊ∞ó„Å´„Åó„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑ„ÄÇÂÖ•Âäõ„ÅåÁµÇ‰∫Ü„Åô„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Å¶„ÅØ„ÄÅÂØæË©±Âºè„Ç§„É≥„Çø„Éó„É™„Çø„ÅØ„Åã„Åë„Å™„ÅÑ„ÄÇ

„Åì„Çå„Å´ÂØæ„Åó„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅØ„ÄÅÂÖ•Âäõ„Åå‰∏ÄÂå∫Âàá„Çä‰ªò„ÅÑ„Åü„Åã„Å©„ÅÜ„Åã„Å™„Å©„ÅØ„Å©„ÅÜ„Åß„ÇÇ„Çà„Åè„ÄÅÁµÇ‰∫Ü„Åó„Åü„ÅÆ„ÅãÁµÇ‰∫Ü„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åã„ÅØÊ±∫ÂÆö„Åó„Å™„ÅÑ„Åë„Çå„Å∞„ÅÑ„Åë„Å™„ÅÑ„ÄÇ
„Åì„ÅÆÊÑèÂë≥„Åß„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„Å®REPL„Å®„ÅßÊé°Áî®„Åï„Çå„ÇãÊßãÊñá„ÅØ„ÄÅ„ÄåÂ∑¶ÂÜçÂ∏∞„Äç„Å®„ÄåÂè≥ÂÜçÂ∏∞„Äç„Å®„ÅÑ„ÅÜÁõ∏Âèç„Åô„ÇãÊßãÊñá„Çí„Åù„Çå„Åû„Çå„ÅåÁõÆÁöÑ„Å´Âøú„Åò„Å¶Êé°Áî®„Åô„Çã„ÅÆ„ÅåÈÅ©ÂΩì„Åß„ÅÇ„Çã„ÄÇ



~~~hs
/************   REPL   **********************************************/
input :   /* Left Recursion */
    |                                   { fun _     ->  [],[]                                   }
    | input DOUBLESEMI                  { fun ctx   ->  [],ctx                                  }
    | input oneREPL                     { let _,ev_ctx  = $1 [] in
                                          let cmds,_    = $2 ev_ctx in
                                          let ev_ctx'   = process_commands ev_ctx cmds in
                                          fun _     ->  [],ev_ctx'                              }
oneREPL :
    | Command DOUBLESEMI                { fun ctx   ->  let cmd,ctx'   = $1 ctx in [cmd],ctx'   }
    | Command SEMI oneREPL              { fun ctx   ->  let cmd,ctx'   = $1 ctx in
                                                        let cmds,ctx'' = $3 ctx' in cmd::cmds,ctx''  }
~~~

~~~hs
/************  COMPILER  *********************************************/
toplevel : /* Right Recursion */
    | EOF                               { fun ctx   ->  [],ctx                                  }
    | Command SEMI toplevel             { fun ctx   ->  let cmd,ctx  = $1 ctx in
                                                        let cmds,ctx = $3 ctx in cmd::cmds,ctx  }
~~~



# Simple Extensions

## variants

~~~
Table = Nat‚ÜíOptionalNat;
~~~

represents finite mappings from numbers to numbers: the domain of such a mapping is the set of inputs for which the result is <some=n> for some n. The empty table

~~~
emptyTable = Œªn:Nat. <none=unit> as OptionalNat;
emptyTable : Table
~~~

is a constant function that returns none for every input. The constructor

~~~
extendTable =
    Œªt:Table. Œªm:Nat. Œªv:Nat.
        Œªn:Nat.
        if equal n m
            then <some=v> as OptionalNat
            else t n;
~~~





# Normalization

~~~
          well typed term is "normalizable"
========================================================== def
 well typed program is guranteed to "halt in finite steps"
~~~


## Normalization of Simple Type

### term t is normalizable ?

answer. no

* since application
* $ t _ 1 t _ 2 $ ==> (assumption) ==> $ v _ 1 v _ 2 $ ==> (not normalize) ==> `(\x:T.t)` $ v _ 2 $

<br>

so, we define ;

* $ R _ T $ : a set of closed terms of type T
* $ R _ T (t) \iff t \in R _ T $

we regard $ R _ T $ as Predicates

<br>

### Definition

<br>

$ \require{AMScd} $
$ \begin{CD}
    R _ A (t) \\
    @=def\\
    t \text{ halts}
    \end{CD} $

<br>

$ \begin{CD}
    R _ { T _ 1 \rightarrow T _ 2 } (t) \\
    @=def\\
    t \text { halts} \ \wedge \
    \begin{CD}
        R _ {T _ 1} (s)\\
        @>>>\\
        R _ {T _ 2} (t s)\\
    \end{CD}
\end{CD} $

<br>

### Lemma

$$
{\displaystyle
    \frac
    {R _ T (t)}
    {t \text{ halts}}
}
$$


### Lemma

$$
{\displaystyle
    \frac
    {\text{ t : T } \quad \wedge \quad \text{ t \to t' }}
    {R _ T (t) \iff R _ T (t')}
}
$$

### Lemma

$$
{\displaystyle
    \frac
    {x _ 1 : T _ 1 , \dots, x _ n : T _ n \vdash t : T \quad \wedge \quad
    \forall \ i . R _ {T _ i}(v _ i)}
    {R _ T([x _ 1 \mapsto v _ 1] \dots [x _ n \mapsto v _ n]t)}
}
$$

### Theorem

$$
{\displaystyle
    \frac
    {\vdash t : T}
    {t \text{ is normalizable}}
}
$$

<br>
<br>

# References

## Introduction

<br>

Basics
:
~~~
> f = ref 5 ;
r : Ref Nat

> !r ;
5 : Nat

> r := 7;
unit : Unit

> !r ;
7 : Nat
~~~

<br>

Side Effects and Sequencing
:
~~~
> (r := succ(!r) ; !r) ;
8 : Nat

> (\_:Unit. !r) (r := succ(!r));
9 : Nat

> (r := succ(!r); r := succ(!r); r := succ(!r); r := succ(!r): !r);
13 : Nat
~~~

<br>

References and Aliasing
:
~~~
> s = r;
s : Ref Nat
~~~

*************************
*                       *
*      r          s     *
*       \        /      *
*        v      v       *
*       +--------+      *
*       |   13   |      *
*       +--------+      *
*                       *
*************************

~~~
> s := 82;
unit : Unit

> !r ;
82 : Nat
~~~

<br>

Q. Draw the diagrams of
~~~
> a = {ref 0, ref 0}
> b = (\x:Ref.{x,x}) (ref 0)
~~~

<br>

Shared State
:
~~~
> c = ref 0;
c : Ref Nat

> incc = \x:Unit. (c := succ(!c); !c);
incc : Unit -> Nat

> decc = \x:Unit. (c := pred(!c); !c);
decc : Unit -> Nat

> incc unit;
1 : Nat

> decc unit;
0 : Nat

> o = {i = incc, d = decc};
o : {i: Unit -> Nat, d: Unit -> Nat}
~~~

we will develop this on Chapter 18

<br>

References to Compound Types
:
~~~
> type NatArray = Ref (Nat -> Nat)

> newarr = \_:Unit. ref (\n:Nat.0);
newarr : Unit -> NatArray

> lookup = \a:NatArray. \n:Nat. (!a) n;
lookup : NatArray -> Nat -> Nat

> update = \a:NatArray. \m:Nat. \v:Nat.
            let oldf = !a in
            a := (\n:Nat. if equal m n then v else oldf n);
update : NatArray -> Nat -> Nat -> Unit
~~~

<br>

Q. How about this definition ?
~~~
> update = \a:NatArray. \m:Nat. \v:Nat.
            a := (\n:Nat. if equal m n then v else (!a) n);
~~~

A. No - this function now Diverge.

<br>

Garbage Collection
:

<br>
<br>

## Typing

<br>
$$
{\displaystyle
    \frac
    {\Gamma \vdash t : T}
    {\Gamma \vdash \text{ref } t : \text{Ref } T}
    \text{[T-Ref]}
}
$$

$$
{\displaystyle
    \frac
    {\Gamma \vdash t : \text{Ref } T}
    {\Gamma \vdash !t : T}
    \text{[T-DeRef]}
}
$$

$$
{\displaystyle
    \frac
    {\Gamma \vdash t _ 1 : \text{Ref } T _ 1 \quad \wedge \quad \Gamma \vdash t _ 2 : T _ 2}
    {\Gamma \vdash t _ 1 := t _ 2 : Unit}
    \text{[T-Assign]}
}
$$

<br>

## Evaluation

- $ \mathscr{L} $ : uninterpreted set of store locations
- $ \mu $ : metavariable to range over stores

- before : `t` ==> `t'`

- after  : `t` | $ \mu $ ==> `t'` | $ \mu ' $
    - where
    - $ \mu $ : starting state of the store
    - $ \mu ' $ : ending state of the store

<br>
$$
{\displaystyle
    \frac
    {l \notin dom( \mu )}
    {\text{ref v} _ 1 \rightarrow l \text{ | } ( \mu , l \mapsto \text{v} _ 1)}
    \text{(E-REFV)}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{ref t} _ 1 \text{ | } \mu \rightarrow \text{ref t'} _ 1 \text{ | } \mu '}
    \text{(E-REF)}
}
$$

<br>

### How to model ` Garbage Collection `

„Äå„Åì„Åì„Åã„Çâ„Äç


## Store Typings

## Safety

## ==> Unit Ref

### Syntax
~~~
t ::=
    x
    \x:T.t
    t t
    unit
    ref t           [reference creation]
    !t              [dereference]
    t:=t            [assignment]
    l               [store location]

v ::=
    \x:T.t
    unit
    l               [store location]

T ::=
    T -> T
    Unit
    Ref T           [type of reference cells]

Œì ::=
    ‚àÖ               [empty context]
    Œì, x:T          [term variable binding]

Œº ::=
    ‚àÖ               [empty store]
    Œº,l = v         [location binding]

Œ£ ::=
    ‚àÖ               [empty store typing]
    Œ£,l : T         [location typing]
~~~

### Evaluation

<br>

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{t} _ 1 \text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{t} _ 2 \text{ | } \mu '}
    \text{[E-App1]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 2 \text{ | } \mu '}
    {\text{v} _ 1 \text{t} _ 2 \text{ | } \mu \rightarrow \text{v} _ 1 \text{t'} _ 2 \text{ | } \mu '}
    \text{[E-App2]}
}
$$

$$
( \lambda x : T _ {11} . t _ {12} ) \  v _ 2 \text{ | } \mu \quad \rightarrow \quad
[ x \mapsto v _ 2 ] \  t _ {12} \text{ | } \mu
\quad \quad \text{[E-AppAbs]}
$$

$$
{\displaystyle
    \frac
    {l \notin dom( \mu ) }
    {\text{ref v} _ 1 \rightarrow l \text{ | } ( \mu , l \mapsto \text{v} _ 1)}
    \text{[E-RefV]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{ref t} _ 1 \text{ | } \mu \rightarrow \text{ref t'} _ 1 \text{ | } \mu '}
    \text{[E-Ref]}
}
$$

$$
{\displaystyle
    \frac
    {\mu (l) = \text{v}}
    {\text{!} l \text{ | } \mu \to \text{v | } \mu}
    \text{[E-DerefLoc]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{! t} _ 1 \text{ | } \mu \rightarrow \text{! t'} _ 1 \text{ | } \mu '}
    \text{[E-Deref]}
}
$$

$$
l := \text{v} _ 2 \text{ | } \mu \quad \to \quad \text{unit | } [ l \mapsto \text{v} _ 2 ] \mu ' \quad \text{[E-Assign]}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{t} _ 1 := \text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 1 := \text{t} _ 2 \text{ | } \mu '}
    \text{[E-Assign1]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 2 \text{ | } \mu '}
    {\text{v} _ 1 := \text{t} _ 2 \text{ | } \mu \rightarrow \text{v} _ 1 := \text{t'} _ 2 \text{ | } \mu '}
    \text{[E-Assign2]}
}
$$

<br>

$$
{\displaystyle
    \frac
    {}
    {}
}
$$

### Typing


~~~
e.x. 13.5.2
Œì | Œ£1 |- Œº
Œì | Œ£2 |- Œº

Œì
empty
Œ£1
l |-> () -> (() -> ())
Œ£2
l |-> () -> ()
Œº
l |-> \(). (!l) ()

l |-> \(). (\().(!l)()) () = \(). (!l)() : which type is OK !
~~~


# Exceptions

# Subtyping

# Metatheory of Subtyping

# An ML Implementation of Subtyping

# Case Study : Imperative Objects

# Case Study : Featherweight Java

# Recursive Types

## Examples
Lists
:

Hungry Functions
:

Objects
:

Recursive Values from Recursive Types
:

Untyped Lambda-Calculus, Redux
:


## Formalities

## Subtyping

## Notes

# Metatheory of Recursive Types

## Induction and Coinduction
## Finite and Infinte Types
## Subtyping
## A Digression on Transityvity
## Membership Checking
## More Efficient Algorithm
## Regular Trees
## Œº - Types
## Counting Subexpressions
## Digression: An Exponential Algorithm
## Subtyping Iso-Recursive Types

# Type Reconstruction

## Type Variables and Substitutions
## Two Views of Type Variables
## Constraint-Based Typing
## Unification
## Principal Types
## Implicit Type Annotations
## Let-Polymorphism

### Let polymorphism



### Impredicative Polymorphism

let polymorphism (ML style) v.s. impredicative polymorphism (System F)

* OCaml : let polymorphism can always halt.
* Haskell : impredicative polymorphism cannot halt always.


### Recursive Polymorphism

Recursive Polymorphism allows polymorphisms of type in Recursive Type definitions;
i.e.
if we apply polymorphism to

~~~
Rec X. X -> A
~~~

, we can get the following types as its instances.

~~~
Int -> [Int] -> [[Int]] -> A
Int -> Bool  -> Int     -> Bool -> ... -> A
~~~


Haskell has recursive polymorhism

~~~
Œª>  data Nested a = a :<: (Nested [a]) | E deriving Show
Œª>  length :: Nested a -> Int;
    length E = 0 ;
    length (a :<: as) = 1 + length as
~~~

Then Type;

~~~
Œª>  1 :<: ([1] :<: ([[2]] :<: E  ))
~~~



# Universal Types

## Motivation
## Varieties of Polymorphism
## System F
## Examples
## Basic Properties
## Erasure, Typability, and Type Reconstruction
## Erasure and Evaluation Order
## Fragments of System F
## Parametricity
## Impredicativity

# Existential Types

Existential Type is a tuple (‚àÉX,T) where X is type variable and T is a Type.
We can instantiate, `X` by a concrete Type e.g. `Int` then we get the instance of existential type `(Int, T[X‚Ü¶Int])`.

This instanciation reminds us of Object Oriented Programming.



# An ML Implementation of System F

# Bounded Quantification


##

## Kernel F-sub  v.s. Full F-sub


Kernel F-sub :
~~~
      Œì,X<:U ‚ä¢ S2 <: T2
 ------------------------------[KERNEL S-ALL ]
  Œì ‚ä¢ ‚àÄX<:U.S2 <: ‚àÄX<:U.T2
~~~

This definition can be more generalised since ‚àÄX. T can be thought as
as Œ†-Type, generalisation of arrow-type .
So, it can be rewritten with mimicing `S-ARROW` which is defined Chap 15.

FULL F-sub :
~~~
  Œì ‚ä¢ T1 <: S1   Œì,X<:U ‚ä¢ S2 <: T2
 ----------------------------------[KERNEL S-ALL ]
    Œì ‚ä¢ ‚àÄX<:S1.S2 <: ‚àÄX<:T1.T2
~~~



The Object Oriented Programming Language $ O _ { 1 \<\: } $ can be realised in $ F _ { \<\: Œº } $ .

- [Reference] [Abadi, Cardelli, Viswanathan] An Interpretation of Object Types



# Case Study : Imperative Objects, Redux

# Metatheory of Bounded Quantification



# Type Operators and Kinding

# Higher-Order Polymorphism

# Higher-Order Subtyping

# Case Study: Purely Functional Objects
