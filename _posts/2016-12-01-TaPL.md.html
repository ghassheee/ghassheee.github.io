---
title : TaPL
layout: dep
date : 2016-12-01
---

Reference

* [Pierce] Types and Programming Languages

<br>

# Introduction

TaPL provides type safe programming language definitions.<br>
It is formally named `typed lambda calculus` .<br>
If you are not familir with lambda calculus ,
I recommend you to start with combinator theory .<br>
"Mock a mockingbird" is a book with famous logic thinking puzzle written by Raymond Smullyan.

<br>
<br>
<br>

# Mathematical Prerequired Definitions




* $ \mathcal{P} ( \mathcal{S} ) $ : `powerset` of $ S $

* $ \mathcal{S} \ \backslash \ \mathcal{T} $ : `difference`

* $ \mathbb{N} $ : `set of natural number`

* `n-placed relation`
    - $ s_1 \in \mathcal{S_1} , ... , s_n \in \mathcal{S_n} $ are `related`
    - `if` $ (s_1, ... , s_2) \in R $
    - where $ R \subseteq \mathcal{S_1} \times ... \times \mathcal{S_n} $

* $ P(s) := s \in P $ : `predicate ( 1-place relation )`

* $ s R t := ( s , t ) \in R $ : `Binary Relation`
    * where $ s, t \in \mathcal{ U } $

* $ s R t := ( s , t ) \in R $ : `2-place Relation`
    * where $ s \in \mathcal{S} , t \in \mathcal{T} $

* $ \Gamma \vdash s : T $ : `3-place Relation`
    * this is Typing Relation (see Chapter 9)

* $ R $ is `Partial Function` : $ s R t_1 \wedge s R t_2 \Rightarrow t_1 = t_2 $
* $ R $ is `Total Function` : $ dom(R) = \mathcal{S} $
    * where $ \mathcal{S} R \mathcal{T} $

* `Defined` / `Undefined`
    * Partial Function $ s R t $ is defined on $ s \in \mathcal{S} $ if $ s \in dom(R) $
    * $ f(x) \uparrow $ , $ f(x) = \uparrow $ : $ f $ is undefined on $ x $
    * $ f(x) \downarrow $ , $ f(x) = \downarrow $ : $ f $ is defined on $ x $

* Diverge / Failure
    * `function`の実装時、出力値 `failure` は 出力値 `divergence` と区別しないといけない.
    * fail を出力する関数は `Partial` であり `divergeble` であり得るが、`Total` であれば、入力に再帰は含まれない
    * Rの input である$ dom(R) $ は、$ \mathcal{S} $ の要素に限られる





## `Predicate`　
    - $ s \in P $ であれば sは述語を持つという
    - where $ s \in \mathcal{S} , P \subseteq \mathcal{S} $

e.g.

- $ s \in P := P(\mathcal{S}) = $ { $ True , False $ }
- $ P := s \rightarrow $ { $ True , False $ }



述語を持たせるのは [Russell's Paradox](../math/2015-12-15-russell.md/) を解消させるため


**********************************
*                                *
*         s R t                  *
*         ^   ^                  *
*        /     \                 *
*   domain     range , codomain  *
*   dom(R)        range(R)       *
*                                *
**********************************



# Untyped Arithmetic Expressions

# ML implementation

# Untyped lambda calsulus

## term definition

~~~hs
t ::=
        x               variable
        λx.t            abstraction
        t t             application
~~~

## evaluation definition



## church booleans

~~~hs
tru = \t.\f. t
fls = \t.\f. f
and = \x.\y. x y fls
or  = \x.\y. y tru x
not = \x. x fls tru
~~~

## pairs

~~~
pair = \f.\s.\b. b f s
fst  = \p. p tru
snd  = \p. p fls
~~~


## if

~~~
if b s t = b s t
~~~

## church numerals

### $ \mathbb{N} $

~~~hs
0 = \s.\z. z        -- = \x.\y. y = fls
1 = \s.\z. s z
2 = \s.\z. s (s z)
3 = \s.\z. s (s (s z))
...
~~~



Rewrite in `MockingBird Style`
~~~hs
        0xy = y
        1xy = xy
        2xy = x(xy)
        3xy = x(x(xy))
        ...
~~~

### `succ`

~~~hs
        S0xy = xy
        S1xy = x(xy)
        S2xy = x(x(xy))
        ...
~~~

solve S !
~~~hs
        x(x(xy)) = x(2xy) = S2xy
        x(xy) = x(1xy) = S1xy
        so, Snxy = x(nxy)
        or
        x(x(xy)) = 2x(xy) = S2xy
        x(xy) = 1x(xy) = S1xy
        so , Snxy = nx(xy)
~~~

hence,
~~~hs
suc = \n.\s.\z. s(nsz)
    = \n.\s.\z. ns(sz)
~~~

### `plus`

~~~hs
plus = \m.\n.\x.\y. mx(nxy)
plus m n x y = mx(nxy)

plus m n x y
= x(x(x(x(xy))))
= mx(nxy)
~~~

### `times`

~~~hs
times m n x y
= x(x(x(x(x...(xy)))))    // x appears m * n
= x(x(x(           )))    // now m = 3
= mx   (x(x...(xy)))
= mx(mx(mx..(mxy)))       // mx appears by n times
= n(mx)y
or similarly
= m(nx)y

so
times = \m.\n.\x.\y. m(nx)y
times = \m.\n.\x.\y. n(mx)y
~~~

now with `plus`
~~~
times = \m.\n. m(plus n)0
times m n = m(plus n)0
~~~

### `pow`

in the same way
~~~
pow = \m.\n. m(times n)1
pow m n = m(times n)1
~~~

another solution
~~~
pow = \m.\n. n m
pow m n = n m
~~~

### `iszro`

~~~
iszro = \m. m (\x.fls) tru


let
F x = fls
in
iszro m = m F tru
~~~

e.g.
~~~
iszro 5
= 5 F tru
= F(F(F(F(F tru))))
= fls               // because F always returns fls

iszro 0
= 0 F tru
= tru
~~~

### `prd`

let
~~~
zz = pair 0 0
ss p = pair (snd p) (+ 1 (snd p))
~~~

then pred is
~~~
prd m = fst (m ss zz)
~~~

e.g.
~~~
prd m
= fst (m ss zz)
= fst (ss(ss(...(ss zz)...)))
= fst (pair {m-1} m)
= m-1


where,
ss zz
= pair (snd (pair 0 0)) (+ 1 (snd (pair 0 0)))
= pair 0 1

ss (ss zz)
= pair (snd (pair 0 1)) (+ 1 (snd (pair 0 1)))
= pair 1 2

...
~~~

~~~
prd 0
= fst (0 ss zz)
= fst (zz)
= fst (pair 0 0)
= 0
~~~



### `sub`


~~~
sub m n = n prd m
~~~

### `equal`  / `or` `and`

~~~
equal m n = and (iszro (sub m n))(iszro (sub n m))
~~~

where

~~~
or = \b.\c. b tru c
and = \b.\c. b c fls
~~~


## list

lists are functions like
~~~
[x,y,z] c n = cx(cy(czn))
[x,y] c n = cx(cyn)
[x] c n = cxn
nil c n = n

nil == fls
~~~


cons takes a value and a list and returns a list

~~~
cons x list c n = c x (list c n)



cons x [y,z,a,...] = [x,y,z,a,...]
cons x nil c n
= c x (nil c n)
= c x n
= [x] c n
cons x nil = [x]
~~~


so,lists are composed of cons and its arguments like;
~~~
[x,y,z,a,b]
= cons x [y,z,a,b]
= cons x (cons y [z,a,b])
= cons x (cons y (cons z [a,b]))
= cons x (cons y (cons z (cons a [b])))
= cons x (cons y (cons z (cons a (cons b nil))))
~~~

~~~
[nil] c n
= cons nil nil c n
= [nil] cons nil c n
= cons nil nil c n
= c nil (nil c n)
= c nil n
~~~

so ,it seems that

`nil` $ \neq $ `[nil]`



e.g.
~~~
cons x [y,z] c n
= c x ([y,z] c n)
= c x (c y (c z n))
~~~

~~~
isnil list = list F tru

F x y = fls
~~~

e.g.
~~~
isnil [x]
= [x] F tru
= F x tru
isnil [x,y]
= [x,y] F tru
= F x (F y tru)
~~~

~~~
head list = list tru nil
~~~



tail ..

think the same with `prd`

~~~
pair nil nil
pair nil [z]
pair [y] [y,z]
pair [y,z] [x,y,z]
...

tail list = fst (list cc nn)
cc x p = pair (snd p)(cons x (snd p))
nn = pair nil nil

tail [x,y,..,z]
= fst ([x,y,..,z] cc nn)
= fst (cc x (cc y(..(cc z nn)..)))
= fst (cc x (cc y(..(pair nil [z])..)))
= fst (pair [y,..,z] [x,y,..,z])
= [y,..,z]
~~~

another solution of list
~~~
nil = pair tru tru;
cons = λh. λt. pair fls (pair h t);
head = λz. fst (snd z);
tail = λz. snd (snd z);
isnil = fst;
~~~
mocking bird style;
~~~
nil = pair tru tru
cons x list = pair fls (pair x list)
head list = fst (snd list)
tail list = snd (snd list)
isnil list = fst
~~~

such that ;
~~~
isnil (pair tru tru) = tru
isnil (pair fls (..)) = fls
~~~

but this definition is not satisfying
~~~
[x,t,..,z] c n = cx(cy(..(czn)))
~~~

## Enriching Calculus

## Recursion


fixed point λ function
~~~
fix = \f. (\x.f ( \y.xxy )) (\x.f ( \y.xxy ))
~~~
f_sumlist = \rec.\l. test (isnil l)
                         (\x. 0)
                         (\x. plus (head l) (rec (tail l)))

sumlist = fix f_sumlist

I think that another definition of “sumlist” is very cool,
while the recursive and fixed-point-using one is very long … ( ex 5.2.11 )

~~~
Def.
 sumlist = \x.x plus 0

  e.g.
 sumlist [x,y,z] 
= [x,y,z] plus 0
 = plus x ( plus y ( plus z 0 ))
~~~

moreover ,

~~~
 Def.
 prodlist = \x.x times 1

e.g.
 prodlist [x,y,z]
 = [x,y,z] times 1
 = times x ( times y ( times z 1 ))
~~~

furthermore, we can define “foldr” function in haskell ;

~~~
  Def.
 foldr = \x. \f. \i. x f i  

e.g. 
foldr [x,y,z] f i 
= [x,y,z] f i
 = f x ( f y ( f z i ))
~~~



# de Bruijn

# ML implementation of Lamda Calculus


# Typed Arithmetic Expressions


## Types

~~~
t ::=
    true
    false
    if t then t else t
    0
    succ t
    pred t
    iszero t
~~~

~~~
v ::=
    true
    false
    nv

nv ::=
    0
    succ nv
~~~



## The Typing Relation

$ \mathbb{B} $

~~~
T ::=
    Bool
~~~

~~~
  true : T

  false : T

   t1 : Bool   t2 : T   t3 : T
  ------------------------------
    if t1 then t2 else t3 : T

~~~

$ \mathbb{B}\ \mathbb{N} $
~~~
T ::=
    Nat
~~~

~~~
   0 : Nat

      t1 : Nat
   ----------------
    succ t1 : Nat

      t1 : Nat
   ----------------
    pred t1 : Nat

        t1 : Nat
   ------------------
    iszero t1 : Bool

~~~



## Safety = Progress + Preservation

Progress : A well-typed term is not stuck
~~~
    t is well typed => t is value | t -> t'
~~~

Preservation : (subject reduction)
~~~
    If a well-typed term takes a step of evaluation,
    then the resulting term is also well typed.

    t:T & t->t' => t':T
~~~

### opposite theorem
~~~
    t':T & t->t'  => t:T
~~~
is not True
(if false then true else 0)



### think of `big step`

big step always reach final value.
so you cannot think recursion


### think of `wrong` term

preservation theorem tells:
well-typed term cannot reach wrong term







# Simple Typed Lambda Calculus

## Function Type

~~~
\x.t : ->
~~~


~~~
T ::=
    Bool
    T -> T
~~~

`T->T->T` means `T->(T->T)`  : right associative

## Typing Relation

$ \rightarrow $

~~~
T ::=
     T -> T
~~~

$ \Gamma $ $ ::= $

$ \qquad \varnothing $

$ \qquad \Gamma , x : T $


~~~
         x : T ∈ Γ
      ---------------
         Γ ⊢ x : T


        Γ , x : T1 ⊢ t2 : T2
      --------------------------
        Γ ⊢ \x:T1.t2 : T1->T2


        Γ ⊢ t1 : T11->T12   Γ ⊢ t2 : T2
      ------------------------------------
               Γ ⊢ t1 t2 : T12
~~~





$ \Gamma $ $ \vdash $ t : T

$ \Gamma $ is a set of assumptions and therefore t : T .


$ \Gamma $ :=
~~~
    x_n -> n : Tn
    ...
    x_1 -> 1 : T1
    x_0 -> 0 : T0
~~~









# ML implementaion of Simple Types

# Simple Extensions

## variants

~~~
Table = Nat→OptionalNat;
~~~

represents finite mappings from numbers to numbers: the domain of such a mapping is the set of inputs for which the result is <some=n> for some n. The empty table

~~~
emptyTable = λn:Nat. <none=unit> as OptionalNat;
emptyTable : Table
~~~

is a constant function that returns none for every input. The constructor

~~~
extendTable =
    λt:Table. λm:Nat. λv:Nat.
        λn:Nat.
        if equal n m
            then <some=v> as OptionalNat
            else t n;
~~~





# Normalization

~~~
          well typed term is "normalizable"
========================================================== def
 well typed program is guranteed to "halt in finite steps"
~~~


## Normalization of Simple Type

### term t is normalizable ?

answer. no

* since application
* $ t _ 1 t _ 2 $ ==> (assumption) ==> $ v _ 1 v _ 2 $ ==> (not normalize) ==> `(\x:T.t)` $ v _ 2 $

<br>

so, we define ;

* $ R _ T $ : a set of closed terms of type T
* $ R _ T (t) \iff t \in R _ T $

we regard $ R _ T $ as Predicates

<br>

### Definition

<br>

$ \require{AMScd} $
$ \begin{CD}
    R _ A (t) \\
    @=def\\
    t \text{ halts}
    \end{CD} $

<br>

$ \begin{CD}
    R _ { T _ 1 \rightarrow T _ 2 } (t) \\
    @=def\\
    t \text { halts} \ \wedge \
    \begin{CD}
        R _ {T _ 1} (s)\\
        @>>>\\
        R _ {T _ 2} (t s)\\
    \end{CD}
\end{CD} $

<br>

### Lemma

$$
{\displaystyle
    \frac
    {R _ T (t)}
    {t \text{ halts}}
}
$$


### Lemma

$$
{\displaystyle
    \frac
    {\text{ t : T } \quad \wedge \quad \text{ t \to t' }}
    {R _ T (t) \iff R _ T (t')}
}
$$

### Lemma

$$
{\displaystyle
    \frac
    {x _ 1 : T _ 1 , \dots, x _ n : T _ n \vdash t : T \quad \wedge \quad
    \forall \ i . R _ {T _ i}(v _ i)}
    {R _ T([x _ 1 \mapsto v _ 1] \dots [x _ n \mapsto v _ n]t)}
}
$$

### Theorem

$$
{\displaystyle
    \frac
    {\vdash t : T}
    {t \text{ is normalizable}}
}
$$

<br>
<br>

# References

## Introduction

<br>

Basics
:
~~~
> f = ref 5 ;
r : Ref Nat

> !r ;
5 : Nat

> r := 7;
unit : Unit

> !r ;
7 : Nat
~~~

<br>

Side Effects and Sequencing
:
~~~
> (r := succ(!r) ; !r) ;
8 : Nat

> (\_:Unit. !r) (r := succ(!r));
9 : Nat

> (r := succ(!r); r := succ(!r); r := succ(!r); r := succ(!r): !r);
13 : Nat
~~~

<br>

References and Aliasing
:
~~~
> s = r;
s : Ref Nat
~~~

*************************
*                       *
*      r          s     *
*       \        /      *
*        v      v       *
*       +--------+      *
*       |   13   |      *
*       +--------+      *
*                       *
*************************

~~~
> s := 82;
unit : Unit

> !r ;
82 : Nat
~~~

<br>

Q. Draw the diagrams of
~~~
> a = {ref 0, ref 0}
> b = (\x:Ref.{x,x}) (ref 0)
~~~

<br>

Shared State
:
~~~
> c = ref 0;
c : Ref Nat

> incc = \x:Unit. (c := succ(!c); !c);
incc : Unit -> Nat

> decc = \x:Unit. (c := pred(!c); !c);
decc : Unit -> Nat

> incc unit;
1 : Nat

> decc unit;
0 : Nat

> o = {i = incc, d = decc};
o : {i: Unit -> Nat, d: Unit -> Nat}
~~~

we will develop this on Chapter 18

<br>

References to Compound Types
:
~~~
> type NatArray = Ref (Nat -> Nat)

> newarr = \_:Unit. ref (\n:Nat.0);
newarr : Unit -> NatArray

> lookup = \a:NatArray. \n:Nat. (!a) n;
lookup : NatArray -> Nat -> Nat

> update = \a:NatArray. \m:Nat. \v:Nat.
            let oldf = !a in
            a := (\n:Nat. if equal m n then v else oldf n);
update : NatArray -> Nat -> Nat -> Unit
~~~

<br>

Q. How about this definition ?
~~~
> update = \a:NatArray. \m:Nat. \v:Nat.
            a := (\n:Nat. if equal m n then v else (!a) n);
~~~

A. No - this function now Diverge.

<br>

Garbage Collection
:

<br>
<br>

## Typing

<br>
$$
{\displaystyle
    \frac
    {\Gamma \vdash t : T}
    {\Gamma \vdash \text{ref } t : \text{Ref } T}
    \text{[T-Ref]}
}
$$

$$
{\displaystyle
    \frac
    {\Gamma \vdash t : \text{Ref } T}
    {\Gamma \vdash !t : T}
    \text{[T-DeRef]}
}
$$

$$
{\displaystyle
    \frac
    {\Gamma \vdash t _ 1 : \text{Ref } T _ 1 \quad \wedge \quad \Gamma \vdash t _ 2 : T _ 2}
    {\Gamma \vdash t _ 1 := t _ 2 : Unit}
    \text{[T-Assign]}
}
$$

<br>

## Evaluation

- $ \mathscr{L} $ : uninterpreted set of store locations
- $ \mu $ : metavariable to range over stores

- before : `t` ==> `t'`

- after  : `t` | $ \mu $ ==> `t'` | $ \mu ' $
    - where
    - $ \mu $ : starting state of the store
    - $ \mu ' $ : ending state of the store

<br>
$$
{\displaystyle
    \frac
    {l \notin dom( \mu )}
    {\text{ref v} _ 1 \rightarrow l \text{ | } ( \mu , l \mapsto \text{v} _ 1)}
    \text{(E-REFV)}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{ref t} _ 1 \text{ | } \mu \rightarrow \text{ref t'} _ 1 \text{ | } \mu '}
    \text{(E-REF)}
}
$$

<br>

### How to model ` Garbage Collection `

「ここから」


## Store Typings

## Safety

## ==> Unit Ref

### Syntax
~~~
t ::=
    x
    \x:T.t
    t t
    unit
    ref t           [reference creation]
    !t              [dereference]
    t:=t            [assignment]
    l               [store location]

v ::=
    \x:T.t
    unit
    l               [store location]

T ::=
    T -> T
    Unit
    Ref T           [type of reference cells]

Γ ::=
    ∅               [empty context]
    Γ, x:T          [term variable binding]

μ ::=
    ∅               [empty store]
    μ,l = v         [location binding]

Σ ::=
    ∅               [empty store typing]
    Σ,l : T         [location typing]
~~~

### Evaluation

<br>

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{t} _ 1 \text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{t} _ 2 \text{ | } \mu '}
    \text{[E-App1]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 2 \text{ | } \mu '}
    {\text{v} _ 1 \text{t} _ 2 \text{ | } \mu \rightarrow \text{v} _ 1 \text{t'} _ 2 \text{ | } \mu '}
    \text{[E-App2]}
}
$$

$$
( \lambda x : T _ {11} . t _ {12} ) \  v _ 2 \text{ | } \mu \quad \rightarrow \quad
[ x \mapsto v _ 2 ] \  t _ {12} \text{ | } \mu
\quad \quad \text{[E-AppAbs]}
$$

$$
{\displaystyle
    \frac
    {l \notin dom( \mu ) }
    {\text{ref v} _ 1 \rightarrow l \text{ | } ( \mu , l \mapsto \text{v} _ 1)}
    \text{[E-RefV]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{ref t} _ 1 \text{ | } \mu \rightarrow \text{ref t'} _ 1 \text{ | } \mu '}
    \text{[E-Ref]}
}
$$

$$
{\displaystyle
    \frac
    {\mu (l) = \text{v}}
    {\text{!} l \text{ | } \mu \to \text{v | } \mu}
    \text{[E-DerefLoc]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{! t} _ 1 \text{ | } \mu \rightarrow \text{! t'} _ 1 \text{ | } \mu '}
    \text{[E-Deref]}
}
$$

$$
l := \text{v} _ 2 \text{ | } \mu \quad \to \quad \text{unit | } [ l \mapsto \text{v} _ 2 ] \mu ' \quad \text{[E-Assign]}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 1 \text{ | } \mu \rightarrow \text{t'} _ 1 \text{ | } \mu '}
    {\text{t} _ 1 := \text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 1 := \text{t} _ 2 \text{ | } \mu '}
    \text{[E-Assign1]}
}
$$

$$
{\displaystyle
    \frac
    {\text{t} _ 2 \text{ | } \mu \rightarrow \text{t'} _ 2 \text{ | } \mu '}
    {\text{v} _ 1 := \text{t} _ 2 \text{ | } \mu \rightarrow \text{v} _ 1 := \text{t'} _ 2 \text{ | } \mu '}
    \text{[E-Assign2]}
}
$$

<br>

$$
{\displaystyle
    \frac
    {}
    {}
}
$$

### Typing


~~~
e.x. 13.5.2
Γ | Σ1 |- μ
Γ | Σ2 |- μ

Γ
empty
Σ1
l |-> () -> (() -> ())
Σ2
l |-> () -> ()
μ
l |-> \(). (!l) ()

l |-> \(). (\().(!l)()) () = \(). (!l)() : which type is OK !
~~~


# Exceptions

# Subtyping

# Metatheory of Subtyping

# An ML Implementation of Subtyping

# Case Study : Imperative Objects

# Case Study : Featherweight Java

# Recursive Types

## Examples
Lists
:

Hungry Functions
:

Objects
:

Recursive Values from Recursive Types
:

Untyped Lambda-Calculus, Redux
:


## Formalities

## Subtyping

## Notes

# Metatheory of Recursive Types

## Induction and Coinduction
## Finite and Infinte Types
## Subtyping
## A Digression on Transityvity
## Membership Checking
## More Efficient Algorithm
## Regular Trees
## $ \mu $ - Types
## Counting Subexpressions
## Digression: An Exponential Algorithm
## Subtyping Iso-Recursive Types

# Type Reconstruction

## Type Variables and Substitutions
## Two Views of Type Variables
## Constraint-Based Typing
## Unification
## Principal Types
## Implicit Type Annotations
## Let-Polymorphism

### Let polymorphism



### Impredicative Polymorphism

let polymorphism (ML style) v.s. impredicative polymorphism (System F)

* OCaml : let polymorphism can always halt.
* Haskell : impredicative polymorphism cannot halt always.


### Recursive Polymorphism

Recursive Polymorphism allows polymorphisms of type in Recursive Type definitions;
i.e.
if we apply polymorphism to

~~~
Rec X. X -> A
~~~

, we can get the following types as its instances.

~~~
Int -> [Int] -> [[Int]] -> A
Int -> Bool  -> Int     -> Bool -> ... -> A
~~~


Haskell has recursive polymorhism

~~~
λ>  data Nested a = a :<: (Nested [a]) | E deriving Show
λ>  length :: Nested a -> Int;
    length E = 0 ;
    length (a :<: as) = 1 + length as
~~~

Then Type;

~~~
λ>  1 :<: ([1] :<: ([[2]] :<: E  ))
~~~



# Universal Types

## Motivation
## Varieties of Polymorphism
## System F
## Examples
## Basic Properties
## Erasure, Typability, and Type Reconstruction
## Erasure and Evaluation Order
## Fragments of System F
## Parametricity
## Impredicativity

# Existential Types



# An ML Implementation of System F

# Bounded Quantification

# Case Study : Imperative Objects, Redux

# Metatheory of Bounded Quantification



# Type Operators and Kinding

# Higher-Order Polymorphism

# Higher-Order Subtyping

# Case Study: Purely Functional Objects
